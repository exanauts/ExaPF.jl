var documenterSearchIndex = {"docs":
[{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"CurrentModule = ExaPF\nconst PS = ExaPF.PowerSystem","category":"page"},{"location":"lib/formulations.html#Polar-formulation","page":"Polar formulation","title":"Polar formulation","text":"","category":"section"},{"location":"lib/formulations.html#Generic-templates","page":"Polar formulation","title":"Generic templates","text":"","category":"section"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"AbstractVariable\nAbstractFormulation\nState\nControl\n","category":"page"},{"location":"lib/formulations.html#ExaPF.AbstractVariable","page":"Polar formulation","title":"ExaPF.AbstractVariable","text":"AbstractVariable\n\nVariables corresponding to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.AbstractFormulation","page":"Polar formulation","title":"ExaPF.AbstractFormulation","text":"AbstractFormulation\n\nInterface between the data and the mathemical formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.State","page":"Polar formulation","title":"ExaPF.State","text":"State <: AbstractVariable\n\nAll variables x depending on the variables Control u through the non-linear equation g(x u) = 0.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.Control","page":"Polar formulation","title":"ExaPF.Control","text":"Control <: AbstractVariable\n\nIndependent variables u used in the reduced-space formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#Structure-and-variables","page":"Polar formulation","title":"Structure and variables","text":"","category":"section"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"PolarForm\nNetworkStack\ninit!\n","category":"page"},{"location":"lib/formulations.html#ExaPF.PolarForm","page":"Polar formulation","title":"ExaPF.PolarForm","text":"PolarForm{T, IT, VT, MT} <: AbstractFormulation\n\nWrap a PS.PowerNetwork network to load the data on the target device (CPU() and CUDADevice() are currently supported).\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.NetworkStack","page":"Polar formulation","title":"ExaPF.NetworkStack","text":"NetworkStack <: AbstractStack\nNetworkStack(polar::PolarForm)\nNetworkStack(nbus::Int, ngen::Int, nlines::Int, VT::Type)\n\nStore the variables associated to the polar formulation. The variables are stored in the field input, ordered as follows\n\n    input = [vmag ; vang ; pgen]\n\nThe object stores also intermediate variables needed in the expression tree, such as the LKMR basis ψ.\n\nNotes\n\nThe NetworkStack can be instantiated on the host or on the target device.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.init!","page":"Polar formulation","title":"ExaPF.init!","text":"init!(polar::PolarForm, stack::NetworkStack)\n\nSet stack.input with the initial values specified in the base PS.PowerNetwork object.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"The state and the control are defined as mapping:","category":"page"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"mapping\n","category":"page"},{"location":"lib/formulations.html#ExaPF.mapping","page":"Polar formulation","title":"ExaPF.mapping","text":"mapping(polar::PolarForm, ::State)\n\nReturn the mapping associated to the State() in NetworkStack according to the polar formulation PolarForm.\n\n\n\n\n\nmapping(polar::PolarForm, ::Control)\n\nReturn the mapping associated to the Control() in NetworkStack according to the polar formulation PolarForm.\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#Powerflow-solver","page":"Polar formulation","title":"Powerflow solver","text":"","category":"section"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"run_pf\nNewtonRaphson\n","category":"page"},{"location":"lib/formulations.html#ExaPF.run_pf","page":"Polar formulation","title":"ExaPF.run_pf","text":"run_pf(\n    polar::PolarForm, stack::NetworkStack;\n    rtol=1e-8, max_iter=20, verbose=0,\n)\n\nSolve the power flow equations g(x u) = 0 w.r.t. the stack x, using the (NewtonRaphson algorithm. The initial state x is specified implicitly inside stack, with the mapping mapping associated to the polar formulation. The object stack is modified inplace in the function.\n\nThe algorithm stops when a tolerance rtol or a maximum number of iterations maxiter is reached.\n\nArguments\n\npolar::AbstractFormulation: formulation of the power flow equation\nstack::NetworkStack: initial values in the network\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations.html#ExaPF.NewtonRaphson","page":"Polar formulation","title":"ExaPF.NewtonRaphson","text":"NewtonRaphson <: AbstractNonLinearSolver\n\nNewton-Raphson algorithm.\n\nAttributes\n\nmaxiter::Int (default 20): maximum number of iterations\ntol::Float64 (default 1e-8): tolerance of the algorithm\nverbose::Int (default 0): verbosity level\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#Constraints","page":"Polar formulation","title":"Constraints","text":"","category":"section"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"The different parts of the polar formulation are implemented in the following AbstractExpression:","category":"page"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"PolarBasis\nPowerFlowBalance\nVoltageMagnitudeBounds\nPowerGenerationBounds\nLineFlows\n","category":"page"},{"location":"lib/formulations.html#ExaPF.PolarBasis","page":"Polar formulation","title":"ExaPF.PolarBasis","text":"PolarBasis{VI, MT} <: AbstractExpression\nPolarBasis(polar::PolarForm)\n\nImplement the LKMR nonlinear basis. Takes as input the voltage magnitudes vmag and the voltage angles vang and returns\n\n    beginaligned\n         psi_ell^C(v theta) = v^f  v^t  cos(theta_f - theta_t) quad forall ell = 1 cdots n_ell \n         psi_ell^S(v theta) = v^f  v^t  sin(theta_f - theta_t) quad forall ell = 1 cdots n_ell \n         psi_k(v theta) = v_k^2 quad forall k = 1 cdots n_b\n    endaligned\n\nDimension: 2 * n_lines + n_bus\n\nComplexity\n\n3 n_lines + n_bus mul, n_lines cos and n_lines sin\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.PowerFlowBalance","page":"Polar formulation","title":"ExaPF.PowerFlowBalance","text":"PowerFlowBalance{VT, MT}\nPowerFlowBalance(polar)\n\nImplement a subset of the power injection corresponding to (p_inj^pv p_inj^pq q_inj^pq). The function encodes the active balance equations at PV and PQ nodes, and the reactive balance equations at PQ nodes:\n\nbeginaligned\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \n     i  PV PQ \n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j))  \n     i  PQ\nendaligned\n\nDimension: n_{pv} + 2 * n_{pq}\n\nComplexity\n\n2 SpMV\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.VoltageMagnitudeBounds","page":"Polar formulation","title":"ExaPF.VoltageMagnitudeBounds","text":"VoltageMagnitudeBounds\n\nImplement the bounds on voltage magnitudes not taken into account in the bound constraints. In the reduced space, this is associated to the the voltage magnitudes at PQ nodes:\n\nv_pq^  v_pq  v_pq^ \n\nDimension: n_pq\n\nComplexity\n\n1 copyto\n\nNote\n\nIn the reduced space, the constraints on the voltage magnitudes at PV nodes v_pv are taken into account when bounding the control u.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.PowerGenerationBounds","page":"Polar formulation","title":"ExaPF.PowerGenerationBounds","text":"PowerGenerationBounds{VT, MT}\nPowerGenerationBounds(polar)\n\nConstraints on the active power productions and on the reactive power productions that are not already taken into account in the bound constraints. In the reduced space, that amounts to\n\np_gref^  p_gref  p_gref^  \nC_g q_g^  C_g q_g  C_g q_g^  \n\nDimension: n_pv + 2 n_ref\n\nComplexity\n\n1 copyto, 1 SpMV\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.LineFlows","page":"Polar formulation","title":"ExaPF.LineFlows","text":"LineFlows{VT, MT}\nLineFlows(polar)\n\nImplement thermal limit constraints on the lines of the network.\n\nDimension: 2 * n_lines\n\nComplexity\n\n4 SpMV, 4 * n_lines quadratic, 2 * n_lines add\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#Objective","page":"Polar formulation","title":"Objective","text":"","category":"section"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"The production costs is given in the AbstractExpression CostFunction:","category":"page"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"CostFunction","category":"page"},{"location":"lib/formulations.html#ExaPF.CostFunction","page":"Polar formulation","title":"ExaPF.CostFunction","text":"CostFunction{VT, MT} <: AutoDiff.AbstractExpression\nCostFunction(polar)\n\nImplement the quadratic cost function for OPF\n\n    _g=1^n_g c_2g p_g^2 + c_1g p_g + c_0g\n\nDimension: 1\n\nComplexity\n\n1 SpMV, 1 sum\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#Composition-of-expressions","page":"Polar formulation","title":"Composition of expressions","text":"","category":"section"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"The different expressions can be combined together in several different ways.","category":"page"},{"location":"lib/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"MultiExpressions\nComposedExpressions","category":"page"},{"location":"lib/formulations.html#ExaPF.MultiExpressions","page":"Polar formulation","title":"ExaPF.MultiExpressions","text":"MultiExpressions <: AbstractExpression\n\nImplement expressions concatenation. Takes as input a vector of expressions [expr1,...,exprN] and concatenate them in a single expression mexpr, such that\n\n    mexpr(x) = [expr1(x) ; expr2(x) ; ... ; exprN(x)]\n\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations.html#ExaPF.ComposedExpressions","page":"Polar formulation","title":"ExaPF.ComposedExpressions","text":"ComposedExpressions{Expr1<:PolarBasis, Expr2} <: AbstractExpression\n\nImplement expression composition. Takes as input two expressions expr1 and expr2 and returns a composed expression cexpr such that ```     cexpr(x) = expr2 ∘ expr1(x)\n\nNotes\n\nCurrently, only PolarBasis is supported for expr1.\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF.AutoDiff","category":"page"},{"location":"lib/autodiff.html#AutoDiff","page":"AutoDiff","title":"AutoDiff","text":"","category":"section"},{"location":"lib/autodiff.html#Variables","page":"AutoDiff","title":"Variables","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"AbstractStack\n","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.AbstractStack","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractStack","text":"AbstractStack{VT}\n\nAbstract variable storing the inputs and the intermediate values in the expression tree.\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#Expressions","page":"AutoDiff","title":"Expressions","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"AbstractExpression\nadjoint!\n","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.AbstractExpression","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractExpression","text":"AbstractExpression\n\nAbstract type for differentiable function f(x). Any AbstractExpression implements two functions: a forward mode to evaluate f(x), and an adjoint to evaluate f(x).\n\nForward mode\n\nThe direct evaluation of the function f is implemented as\n\n(expr::AbstractExpression)(output::VT, stack::AbstractStack{VT}) where VT<:AbstractArray\n\n\nthe input being specified in stack, the results being stored in the array output.\n\nReverse mode\n\nThe adjoint of the function is specified by the function adjoint!, with the signature:\n\nadjoint!(expr::AbstractExpression, ∂stack::AbstractStack{VT}, stack::AbstractStack{VT}, ̄v::VT) where VT<:AbstractArray\n\n\nThe variable stack stores the result of the direct evaluation, and is not modified in adjoint!. The results are stored inside the adjoint stack ∂stack.\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.adjoint!","page":"AutoDiff","title":"ExaPF.AutoDiff.adjoint!","text":"adjoint!(expr::AbstractExpression, ∂stack::AbstractStack{VT}, stack::AbstractStack{VT}, ̄v::VT) where VT<:AbstractArray\n\nCompute the adjoint of the AbstractExpression expr with relation to the adjoint vector ̄v. The results are stored in the adjoint stack ∂stack. The variable stack stores the result of a previous direct evaluation, and is not modified in adjoint!.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#First-and-second-order-derivatives","page":"AutoDiff","title":"First and second-order derivatives","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"AbstractJacobian\nAbstractHessianProd\nAbstractFullHessian","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.AbstractJacobian","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractJacobian","text":"AbstractJacobian\n\nAutomatic differentiation for the compressed Jacobian of any nonlinear constraint h(x).\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.AbstractHessianProd","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractHessianProd","text":"AbstractHessianProd\n\nReturns the adjoint-Hessian-vector product λ^ H v of any nonlinear constraint h(x).\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.AbstractFullHessian","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractFullHessian","text":"AbstractHessianProd\n\nFull sparse Hessian H of any nonlinear constraint h(x).\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff.html#Utils","page":"AutoDiff","title":"Utils","text":"","category":"section"},{"location":"lib/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"seed!\nseed_coloring!\npartials!\nset_value!","category":"page"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.seed!","page":"AutoDiff","title":"ExaPF.AutoDiff.seed!","text":"seed!(\n    H::AbstractHessianProd,\n    v::AbstractVector{T},\n) where {T}\n\nSeed the duals with v to compute the Hessian vector product λ^ H v.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.seed_coloring!","page":"AutoDiff","title":"ExaPF.AutoDiff.seed_coloring!","text":"seed_coloring!(\n    M::Union{AbstractJacobian, AbstractFullHessian}\n    coloring::AbstractVector,\n)\n\nSeed the duals with the coloring based seeds to compute the Jacobian or Hessian M.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.partials!","page":"AutoDiff","title":"ExaPF.AutoDiff.partials!","text":"partials!(jac::AbstractJacobian)\n\nExtract partials from Jacobian jac in jac.J.\n\n\n\n\n\npartials!(hess::AbstractFullHessian)\n\nExtract partials from Hessian hess into hess.H.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#ExaPF.AutoDiff.set_value!","page":"AutoDiff","title":"ExaPF.AutoDiff.set_value!","text":"set_value!(\n    jac,\n    primals::AbstractVector{T}\n) where {T}\n\nSet values of ForwardDiff.Dual numbers in jac to primals.\n\n\n\n\n\n","category":"function"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const PS = ExaPF.PowerSystem\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/powersystem.html#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"The main goal of ExaPF.jl is the solution of optimization problems for electrical power systems in the steady state. The first step in this process is the creation of an object that describes the physics and topology of the power system which ultimately will be mapped into an abstract mathematical optimization problem. In this section we briefly review the power system in the steady state and describe the tools to create and examine power systems in ExaPF.jl.","category":"page"},{"location":"man/powersystem.html#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"The electrical power system is represented as a linear, lumped network which has to satisfy the Kirchhoff laws:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"    bmi = bmYbmv ","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"where bmi bmv in mathbbC^N_B are the current and voltage vectors associated to the system and bmY in mathbbC^N_B times N_B is the admittance matrix. These equations are often rewritten in terms of apparent powers:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"    bms = bmp + jbmq = textitdiag(bmv^*) bmYbmv","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Using polar representation of the voltage vector, such as bmv = ve^j theta, each bus i=1 cdots N_B  must satisfy the power balance equations:","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"beginaligned\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j)) \nendaligned","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"where each bus i has variables p_i q_i v_i theta_i and the topology of the network is defined by a non-negative value of the admittance between two buses i and j, y_ij = g_ij + ib_ij.","category":"page"},{"location":"man/powersystem.html#The-PowerNetwork-Object","page":"PowerSystem","title":"The PowerNetwork Object","text":"","category":"section"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Currently we can create a PowerNetwork object by parsing a MATPOWER data file.","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> datafile = joinpath(artifact\"ExaData\", \"ExaData\", \"case9.raw\")\njulia> ps = PowerSystem.PowerNetwork(datafile)","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Apart of MATPOWER data file, PSSE data file are also supported (also contained in the ExaData artifact)","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> datafile = joinpath(artifact\"ExaData\", \"ExaData\", \"case14.raw\")\njulia> ps = PowerSystem.PowerNetwork(datafile)","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"If we print the object, we will obtain bus information, initial voltage, and power that we read from the data file.","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> println(ps)\nPower Network characteristics:\n    Buses: 9. Slack: 1. PV: 2. PQ: 6\n    Generators: 3.\n    ==============================================\n    BUS      TYPE    VMAG    VANG    P   Q\n    ==============================================\n    1     3      1.000  0.00    0.000   0.000\n    2     2      1.000  0.00    1.630   0.000\n    3     2      1.000  0.00    0.850   0.000\n    4     1      1.000  0.00    0.000   0.000\n    5     1      1.000  0.00    -0.900  -0.300\n    6     1      1.000  0.00    0.000   0.000\n    7     1      1.000  0.00    -1.000  -0.350\n    8     1      1.000  0.00    0.000   0.000\n    9     1      1.000  0.00    -1.250  -0.500","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"then, using multiple dispatch, we have defined a set of abstract data types and getter functions which allow us to retrieve information from the PowerNetwork object","category":"page"},{"location":"man/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"julia> PowerSystem.get(ps, PowerSystem.NumberOfPQBuses())\n6\njulia> PowerSystem.get(ps, PowerSystem.NumberOfPVBuses())\n2\njulia> PowerSystem.get(ps, PowerSystem.NumberOfSlackBuses())\n1","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const Precondition = ExaPF.Precondition\n    const Iterative = ExaPF.Iterative\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/linearsolver.html#Linear-Solver","page":"Linear Solvers","title":"Linear Solver","text":"","category":"section"},{"location":"man/linearsolver.html#Overview","page":"Linear Solvers","title":"Overview","text":"","category":"section"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"As mentioned before, a linear solver is required to compute the Newton step in","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"dx .= jacobian(x)\\f(x)","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"Our package supports the following linear solvers:","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"cuSOLVER with csrlsvqr (GPU),\nKrylov.jl with dqgmres and bicgstab (CPU/GPU),\nUMFPACK through the default Julia \\ operator (CPU),\ngeneric BiCGSTAB implementation [Vorst1992] (CPU/GPU),\nor any linear solver wrapped in LinearAlgebra.","category":"page"},{"location":"man/linearsolver.html#Preconditioning","page":"Linear Solvers","title":"Preconditioning","text":"","category":"section"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"Using only an iterative solver leads to divergence and bad performance due to ill-conditioning of the Jacobian. This is a known phenomenon in power systems. That's why this package comes with a block Jacobi preconditioner that is tailored towards GPUs and is proven to work well with power flow problems.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"The Jacobian is partitioned into a dense block diagonal structure using Metis.jl, where each block is inverted to build our preconditioner P.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"(Image: Dense block Jacobi preconditioner \\label{fig:preconditioner})","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"Compared to incomplete Cholesky and incomplete LU this preconditioner is easily portable to the GPU if the number of blocks is high enough. ExaPF.jl uses the batch BLAS calls from cuBLAS to invert the single blocks.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"CUDA.@sync pivot, info = CUDA.CUBLAS.getrf_batched!(blocks, true)\nCUDA.@sync pivot, info, p.cuJs = CUDA.CUBLAS.getri_batched(blocks, pivot)","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"Assuming that other vendors will provide such batched BLAS APIs, this code is portable to other GPU architectures.","category":"page"},{"location":"man/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"[Vorst1992]: Vorst, H. A. van der. 1992. “Bi-Cgstab: A Fast and Smoothly Converging Variant of Bi-Cg for the Solution of Nonsymmetric Linear Systems.”SIAM Journal on Scientific and Statistical Computing 13 (2): 631–44","category":"page"},{"location":"artifact.html#ExaData-Artifact","page":"ExaData Artifact","title":"ExaData Artifact","text":"","category":"section"},{"location":"artifact.html","page":"ExaData Artifact","title":"ExaData Artifact","text":"The ExaData artifact contains test cases relevant to the Exascale Computing Project. It is built from the git repository available at ExaData. Apart from the standard MATPOWER files it additionally contains demand scenarios and contingencies used in multiperiod security constrained optimal power flow settings.","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/benchmark.html#Benchmark","page":"Benchmark","title":"Benchmark","text":"","category":"section"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"For the purpose of performance regression testing, ExaPF provides a lightweight benchmark script. It allows to test the various configurations for the linear solvers used in the Newton-Raphson algorithm, and run them on a specific hardware. The main julia script benchmark/benchmarks.jl takes all its options from the command line. The benchmark script takes as input a linear solver (e.g. KrylovBICGSTAB), a target architecture as a KernelAbstractions object (CPU or CUDADevice), and a case filename which is included in the ExaData artifact. An exhaustive list of all available linear solvers can be obtained via ExaPF.LinearSolvers.list_solvers.","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"Running","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"julia --project benchmark/benchmarks.jl KrylovBICGSTAB CUDADevice case300.m","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"yields","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"KrylovBICGSTAB, CUDADevice, case300.m,  69.0,  3.57,  43.7, true","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"The first three fields are the settings of the benchmark run. They are followed by three timings in milliseconds:","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"the time taken by the Newton-Raphson algorithm to solve the power flow,\nthe timings for the Jacobian accumulation using AutoDiff,\nand the time for the linear solver, including the preconditioner.","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"To acquire these timings the code is run three times to avoid any precompilation effects. The last field confirms the Newton-Raphson convergence. In case more verbose output is desired, one has to manually set the verbosity in benchmark/benchmarks.jl by changing","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"powerflow_solver = NewtonRaphson(tol=ntol)","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"to one of the following options:","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"powerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_NONE)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_LOW)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_MEDIUM)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_HIGH)","category":"page"},{"location":"man/benchmark.html","page":"Benchmark","title":"Benchmark","text":"A shell script benchmark/benchmarks.sh is provided to gather timings with various canonical configurations and storing them in a file cpu_REV.log and gpu_REF.log, where REV is the sha1 hash of the current checked out ExaPF version.","category":"page"},{"location":"man/formulations.html#Formulations","page":"Polar formulation","title":"Formulations","text":"","category":"section"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"ExaPF's formalism is based on a vectorized formulation of the power flow problem, as introduced in Lee, Turitsyn, Molzahn, Roald (2020). Throughout this page, we will refer to this formulation as LTMR2020. It is equivalent to the classical polar formulation of the OPF.","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"In what follows, we denote by v in mathbbR^n_b the voltage magnitudes, theta in mathbbR^n_b the voltage angles and p_g q_g in mathbbR^n_g the active and reactive power generations. The active and reactive loads are denoted respectively by p_d q_d in mathbbR^n_b.","category":"page"},{"location":"man/formulations.html#Power-flow-model","page":"Polar formulation","title":"Power flow model","text":"","category":"section"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"The idea is to factorize all nonlinearities inside a basis function depending both on the voltage magnitudes v and voltage angles theta, such that psi mathbbR^n_b times mathbbR^n_b to mathbbR^2n_ell + n_b. If we introduce the intermediate expressions","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"    psi_ell^C(v theta) = v^f  v^t  cos(theta_f - theta_t) quad forall ell = 1 cdots n_ell \n    psi_ell^S(v theta) = v^f  v^t  sin(theta_f - theta_t) quad forall ell = 1 cdots n_ell \n    psi_k(v theta) = v_k^2 quad forall k = 1 cdots n_b","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"the basis psi is defined as","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"    psi(v theta) = psi_ell^C(v theta)^top  psi_ell^S(v theta)^top  psi_k(v theta)^top   ","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"The basis psi encodes all the nonlinearities in the problem. For instance, the power flow equations rewrite directly as","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"    beginbmatrix\n    C_g p_g - p_d \n    C_g q_g - q_d\n    endbmatrix\n    +\n    underbrace\n    beginbmatrix\n    - hatG^c  - hatB^s  -G^d \n     hatB^c  - hatG^s  B^d\n    endbmatrix\n    _M\n    psi(v theta)\n    = 0","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"with C_g in mathbbR^n_b times n_g the bus-generators incidence matrix, and the matrices B G defined from the admittance matrix Y_b of the network.","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"Similarly, the line flows rewrite","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"    beginbmatrix\n    s_p^f  s_q^f\n    endbmatrix\n    =\n    overbrace\n    beginbmatrix\n    G_ft  B_ft  G_ff C_f^top \n    -B_ft  G_ft  -B_ff C_f^top\n    endbmatrix\n    ^L_line^f\n    psi(v theta) \n    beginbmatrix\n    s_p^t  s_q^t\n    endbmatrix\n    =\n    underbrace\n    beginbmatrix\n    G_tf  B_tf  G_tt C_t^top \n    -B_tf  G_tf  -B_tt C_t^top\n    endbmatrix\n    _L_line^t\n    psi(v theta)","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"with C_f in mathbbR^n_b times n_ell the bus-from incidence matrix and C_t in mathbbR^n_b times n_ell the bus-to incidence matrix. Then, the line flows constraints write directly with the quadratic expressions:","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"    (s_p^f)^2 + (s_q^f)^2 leq (s^max)^2 quad  \n    (s_p^t)^2 + (s_q^t)^2 leq (s^max)^2 quad  ","category":"page"},{"location":"man/formulations.html#Why-is-this-model-advantageous?","page":"Polar formulation","title":"Why is this model advantageous?","text":"","category":"section"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"Implementing the model LTMR2020 is not difficult once the basis function psi has been defined. Indeed, if we select a subset of the power flow equations (as usual, associated to the active injections at PV nodes, and active and reactive injections at PQ nodes), we get","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"    C_eq p_g + M_eq psi + tau = 0","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"with C_eq defined from the bus-generator incidence matrix C_g, M_eq a subset of the matrix M, tau a constant depending on the loads in the problem. Note that C_eq and M_eq are sparse matrices, so the expression can be implemented efficiently with sparse linear algebra operations (2 SpMV operations, 2 vector additions). The same holds true for the line flow constraints, evaluated with 2 SpMV operations:","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"    s^f = L_line^f psi   quad\n    s^t = L_line^t psi  ","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"In ExaPF, all nonlinear expressions are written as linear operations depending on the nonlinear basis psi. By doing so, all the unstructured sparsity of the power flow problem is directly handled inside the sparse linear algebra library (cusparse on CUDA GPU, SuiteSparse on the CPU).","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"In what follows, we detail the implementation of the LTMR2020 model in ExaPF.","category":"page"},{"location":"man/formulations.html#Implementation","page":"Polar formulation","title":"Implementation","text":"","category":"section"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"We have implemented the LTMR2020 model in ExaPF, both on the CPU and on CUDA GPU. All the operations have been rewritten in a vectorized fashion. Every model depends on inputs we propagate forward with functions. In ExaPF, the inputs will be specified in a NetworkStack <: AbstractStack. The functions will be implemented as AbstractExpressions.","category":"page"},{"location":"man/formulations.html#Specifying-inputs-in-NetworkStack","page":"Polar formulation","title":"Specifying inputs in NetworkStack","text":"","category":"section"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"Our three inputs are (v theta p_g) in mathbbR^2n_b + n_g (voltage magnitude, voltage angle, power generations). The basis psi is considered as an intermediate expression.","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"We store all inputs in a NetworkStack structure:","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"struct NetworkStack{VT} <: AbstractStack\n    input::VT\n    vmag::VT # voltage magnitudes (view)\n    vang::VT # voltage angles (view)\n    pgen::VT # active power generations (view)\n    ψ::VT    # nonlinear basis ψ(vmag, vang)\nend","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"All the inputs are specified in the vector input. The three vectors vmag, vang and pgen are views porting on input, and are defined mostly for convenience. By convention the vector input is ordered as [vmag; vang; pgen]:","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"# Define dimension of the problem\njulia> nbus, ngen, nlines = 3, 2, 4\n# Instantiate stack\njulia> stack = ExaPF.NetworkStack(nbus, ngen, nlines, Vector{Float64});\n\n# Look at values in input\njulia> stack.input'\n1×8 adjoint(::Vector{Float64}) with eltype Float64:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n# Modify values in views\njulia> stack.vmag .= 1\njulia> stack.vang .= 2\njulia> stack.pgen .= 3\n# Look again at the values in input:\njulia> stack.input'\n1×8 adjoint(::Vector{Float64}) with eltype Float64:\n 1.0  1.0  1.0  2.0  2.0  2.0  3.0  3.0","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"The basis vector ψ is an intermediate expression, whose values depend on the inputs.","category":"page"},{"location":"man/formulations.html#Defining-a-state-and-a-control","page":"Polar formulation","title":"Defining a state and a control","text":"","category":"section"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"In the reduced space method, we have to split the variables in a state x and a control u. By default, we define","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"    x = (theta_pv theta_pq v_pq)   quad\n    x = (v_ref v_pv p_ggenpv) ","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"and the control, and was not flexible. In the new implementation, we define the state and the control as two mappings porting on the vector stack.input (which itself stores all the inputs in the problem):","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"# Define dimension of the problem\njulia> nbus, ngen, nlines = 4, 3, 4\n# Instantiate stack\njulia> stack = ExaPF.NetworkStack(nbus, ngen, nlines, Vector{Float64});\n# Define pv, pq, genpv\njulia> ref, pv, pq, genpv = [1], [2], [3, 4], [2, 3]\n# Define state as a mapping on stack.input\n# Remember that ordering of input is [vmag, vang, pgen]!\njulia> mapx = [nbus .+ pv; nbus .+ pq; pq]\njulia> mapu = [ref; pv; genpv]\n# Load values for state and control\njulia> x = @view stack.input[mapx]\njulia> u = @view stack.input[mapu]","category":"page"},{"location":"man/formulations.html","page":"Polar formulation","title":"Polar formulation","text":"By doing so, the values of the state and the control are directly stored inside the NetworkStack structure, avoiding to duplicate values in the memory.","category":"page"},{"location":"quickstart.html#Quick-Start","page":"Quick start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"This page introduces the first steps to set up ExaPF.jl. We show how to load a power network instance and how to solve the power flow equations both on the CPU and on the GPU. The full script is implemented in test/quickstart.jl.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We start by importing CUDA and KernelAbstractions:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"using CUDA\nusing KernelAbstractions\nusing CUDAKernels","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Then, we load ExaPF and its submodules with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"using ExaPF\nimport ExaPF: AutoDiff\nconst PS = ExaPF.PowerSystem\nconst LS = ExaPF.LinearSolvers","category":"page"},{"location":"quickstart.html#Short-version","page":"Quick start","title":"Short version","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"ExaPF loads instances from the pglib-opf benchmark. ExaPF contains an artifact defined in Artifacts.toml that is built from the ExaData repository containing Exascale Computing Project relevant test cases. You may set a data file using","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"datafile = joinpath(artifact\"ExaData\", \"ExaData\", \"case1354.m\")","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"using LazyArtifacts\nusing ExaPF\nusing CUDA\nusing KernelAbstractions\nusing CUDAKernels\nusing ExaPF\nimport ExaPF: AutoDiff\nconst PS = ExaPF.PowerSystem\nconst LS = ExaPF.LinearSolvers\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\ndatafile = joinpath(artifact_path(exadata_hash), \"ExaData\", \"case1354.m\")","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The powerflow equations can be solved in three lines of code, as","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar = ExaPF.PolarForm(datafile, CPU())  # Load data\nstack = ExaPF.NetworkStack(polar)         # Load variables\nconvergence = run_pf(polar, stack; verbose=1)\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Implicitly, ExaPF has just proceed to the following operations:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"instantiate automatically a starting point x_0 from the variables stored in stack\ninstantiate the Jacobian of the powerflow equations using AutoDiff.\nsolve the powerflow equations iteratively, using a Newton-Raphson algorithm.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"This compact syntax allows to solve quickly any powerflow equations in a few lines a code. However, in most case, the user may want more coarse grained control on the different objects manipulated.","category":"page"},{"location":"quickstart.html#Detailed-version","page":"Quick start","title":"Detailed version","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"In what follows, we detail step by step the detailed procedure to solve the powerflow equations.","category":"page"},{"location":"quickstart.html#How-to-load-a-MATPOWER-instance-as-a-PowerNetwork-object?","page":"Quick start","title":"How to load a MATPOWER instance as a PowerNetwork object?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We start by importing a MATPOWER instance to a ExaPF.PowerSystem.PowerNetwork object:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"pf = PS.PowerNetwork(datafile)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The different fields of the object pf specify the characteristics of the network. For instance, we can retrieve the number of buses or get the indexing of the PV buses with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"nbus = PS.get(pf, PS.NumberOfBuses())\npv_indexes = pf.pv;","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"However, a ExaPF.PowerSystem.PowerNetwork object stores only the physical attributes of the network. To choose a given mathematical formulation, we need to pass the object pf to an ExaPF.AbstractFormulation layer. Currently, only the polar formulation is provided with the ExaPF.PolarForm structure. In the future, other formulations (e.g. RectangularForm) may be implemented as well.","category":"page"},{"location":"quickstart.html#How-to-solve-the-powerflow-equations?","page":"Quick start","title":"How to solve the powerflow equations?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"To solve the powerflow equations, we need to choose a given mathematical formulation for the equations of the network. To each formulation corresponds a given state x and control u. Using polar representation of the voltage vector, such as bmv = ve^j theta, each bus i=1 cdots N_B must satisfy the power balance equations:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"beginaligned\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j)) \nendaligned","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The powerflow equations rewrite in the abstract mathematical formalism:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"g(x u) = 0","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"For a given control u, solving the powerflow equations resumes to find a state x(u) such that g(x(u) u) = 0.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"To this goal, ExaPF.jl implements a Newton-Raphson algorithm that allows to solve the powerflow equations in a few lines of code. We first instantiate a PolarForm object to adopt a polar formulation as a model:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar = ExaPF.PolarForm(pf, CPU())","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Note that the constructor ExaPF.PolarForm takes as input a ExaPF.PowerSystem.PowerNetwork object and a KernelAbstractions.jl device (here set to CPU() by default). We will explain in the next section how to load a ExaPF.PolarForm object on the GPU with the help of a CUDADevice().","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The Newton-Raphson solves the equation g(x u) = 0 in an iterative fashion. The algorithm solves at each step the linear equation:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"    x_k+1 = - (nabla_x g_k)^-1 g(x_k u)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Hence, the algorithm requires the following elements:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"an initial variable x_0\na function to solve efficiently the linear system (nabla_x g_k) x_k+1 = g(x_k u)\na function to evaluate the Jacobian nabla_x g_k","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The variable x is instantiated as:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"stack = ExaPF.NetworkStack(polar)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The function g is implemented using ExaPF's custom modeler:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"basis = ExaPF.PolarBasis(polar)\npowerflow = ExaPF.PowerFlowBalance(polar) ∘ basis","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The Jacobian nabla_x g is evaluated automatically using forward-mode AutoDiff:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"mapx = ExaPF.mapping(polar, State());\njx = ExaPF.Jacobian(polar, powerflow, mapx)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The (direct) linear solver can be instantiated directly as","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"linear_solver = LS.DirectSolver(jx.J);\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Let's explain further these three objects.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"stack is a AbstractStack storing all the variables attached to the formulation polar::PolarForm.\njx is a Jacobian structure which allows the solver to compute efficiently the Jacobian of the powerflow equations nabla_x g using AutoDiff.\nlinear_solver specifies the linear algorithm uses to solve the linear system (nabla_x g_k) x_k+1 = g(x_k u). By default, we use direct linear algebra.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"In the AutoDiff Jacobian jx, the evaluation of the Jacobian J is stored in jx.J:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"jac = jx.J","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"This matrix is at the basis of the powerflow algorithm. At each iteration, the AutoDiff backend updates the nonzero values in the sparse Jacobian jx and solve the associated linear system to compute the next descent direction.","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The procedure is implemented in the nlsolve! function, which uses a Newton-Raphson algorithm to solve the powerflow equations. The Newton-Raphson algorithm is specified as:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"pf_algo = NewtonRaphson(; verbose=1, tol=1e-10)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Then, we can solve the powerflow equations simply with","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"convergence = ExaPF.nlsolve!(pf_algo, jx, stack; linear_solver=linear_solver)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Here, the algorithm solves the powerflow equations in 5 iterations. The algorithm modifies the values of stack inplace, to avoid any unnecessary memory allocations.","category":"page"},{"location":"quickstart.html#How-to-deport-the-computation-on-the-GPU?","page":"Quick start","title":"How to deport the computation on the GPU?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Now, how can we deport the resolution on the GPU? The procedure looks exactly the same. It suffices to initiate a new ExaPF.PolarForm object, but on the GPU:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar_gpu = ExaPF.PolarForm(pf, CUDADevice())\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"polar_gpu will load all the structures it needs on the GPU, to avoid unnecessary movements between the host and the device. We can load the other structures directly on the GPU with:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"stack_gpu = ExaPF.NetworkStack(polar_gpu)\n\nbasis_gpu = ExaPF.PolarBasis(polar_gpu)\npflow_gpu = ExaPF.PowerFlowBalance(polar_gpu) ∘ basis_gpu\njx_gpu = ExaPF.Jacobian(polar_gpu, pflow_gpu, mapx)\n\nlinear_solver = LS.DirectSolver(jx_gpu.J)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Then, solving the powerflow equations on the GPU directly translates as","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"convergence = ExaPF.nlsolve!(pf_solver, jx_gpu, stack_gpu; linear_solver=linear_solver)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Note that we get exactly the same iterations as when we solve the power flow equations on the CPU.","category":"page"},{"location":"quickstart.html#How-to-solve-the-linear-system-with-BICGSTAB?","page":"Quick start","title":"How to solve the linear system with BICGSTAB?","text":"","category":"section"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"By default, the algorithm runs with a direct solver, which might be inefficient for large problems. To overcome this issue, ExaPF implements a wrapper for different iterative algorithms (GMRES, BICGSTAB).","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"The performance of iterative solvers is usually improved if we use a preconditioner. ExaPF.jl implements an overlapping Schwarz preconditioner, tailored for GPU usage. To build an instance with 8 blocks, just write","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"npartitions = 8;\njac_gpu = jx_gpu.J;\nprecond = LS.BlockJacobiPreconditioner(jac_gpu, npartitions, CUDADevice());","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"You can attach the preconditioner to an BICGSTAB algorithm simply as","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"linear_solver = ExaPF.KrylovBICGSTAB(jac_gpu; P=precond);\n","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"(this will use the BICGSTAB algorithm implemented in Krylov.jl).","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We need to update accordingly the tolerance of the Newton-Raphson algorithm (the iterative solver is less accurate than the direct solver):","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"pf_algo = NewtonRaphson(; verbose=1, tol=1e-7)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"We reset the variables to their initial values:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"ExaPF.init!(polar_gpu, stack_gpu)","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"Then, solving the power flow with the iterative solvers directly translates to one call to nlsolve!:","category":"page"},{"location":"quickstart.html","page":"Quick start","title":"Quick start","text":"convergence = ExaPF.nlsolve!(pf_algo, jx_gpu, stack_gpu; linear_solver=linear_solver)","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF.PowerSystem","category":"page"},{"location":"lib/powersystem.html#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"lib/powersystem.html#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractPowerSystem\nPowerNetwork","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractPowerSystem","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractPowerSystem","text":"AbstractPowerSystem\n\nFirst layer of the package. Store the topology of a given transmission network, including:\n\nthe power injection at each bus ;\nthe admittance matrix ;\nthe default voltage at each bus.\n\nData are imported either from a matpower file, or a PSSE file.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PowerNetwork","page":"PowerSystem","title":"ExaPF.PowerSystem.PowerNetwork","text":"PowerNetwork <: AbstractPowerSystem\n\nThis structure contains constant parameters that define the topology and physics of the power network.\n\nThe object PowerNetwork uses its own contiguous indexing for the buses. The indexing is independent from those specified in the Matpower or the PSSE input file. However, a correspondence between the two indexing (Input indexing to PowerNetwork indexing) is stored inside the attribute bus_to_indexes.\n\nNote\n\nThe object PowerNetwork is created in the host memory. Use a AbstractFormulation object to move data to the target device.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#API-Reference","page":"PowerSystem","title":"API Reference","text":"","category":"section"},{"location":"lib/powersystem.html#Network-elements","page":"PowerSystem","title":"Network elements","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkElement","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkElement","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkElement","text":"AbstractNetworkElement\n\nAbstraction for all physical elements being parts of a AbstractPowerSystem. Elements are divided in\n\ntransmission lines (Lines)\nbuses (Buses)\ngenerators (Generators)\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of elements:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Buses\nLines\nGenerators","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Buses","page":"PowerSystem","title":"ExaPF.PowerSystem.Buses","text":"Buses <: AbstractNetworkElement\n\nBuses of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Lines","page":"PowerSystem","title":"ExaPF.PowerSystem.Lines","text":"Lines <: AbstractNetworkElement\n\nLines of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.Generators","page":"PowerSystem","title":"ExaPF.PowerSystem.Generators","text":"Generators <: AbstractElement\n\nGenerators in a transmission network\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#Network-attributes","page":"PowerSystem","title":"Network attributes","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkAttribute","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkAttribute","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkAttribute","text":"AbstractNetworkAttribute\n\nAttribute of a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of attributes:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"NumberOfBuses\nNumberOfLines\nNumberOfGenerators\nNumberOfPVBuses\nNumberOfPQBuses\nNumberOfSlackBuses\nBaseMVA\nBusAdmittanceMatrix","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfBuses","text":"NumberOfBuses <: AbstractNetworkAttribute\n\nNumber of buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfLines","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfLines","text":"NumberOfLines <: AbstractNetworkAttribute\n\nNumber of lines in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfGenerators","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfGenerators","text":"NumberOfGenerators <: AbstractNetworkAttribute\n\nNumber of generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfPVBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPVBuses","text":"NumberOfPVBuses <: AbstractNetworkAttribute\n\nNumber of PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfPQBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPQBuses","text":"NumberOfPQBuses <: AbstractNetworkAttribute\n\nNumber of PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.NumberOfSlackBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfSlackBuses","text":"NumberOfSlackBuses <: AbstractNetworkAttribute\n\nNumber of slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.BaseMVA","page":"PowerSystem","title":"ExaPF.PowerSystem.BaseMVA","text":"BaseMVA <: AbstractNetworkAttribute\n\nBase MVA of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.BusAdmittanceMatrix","page":"PowerSystem","title":"ExaPF.PowerSystem.BusAdmittanceMatrix","text":"BusAdmittanceMatrix <: AbstractNetworkAttribute\n\nBus admittance matrix associated with the topology of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Query the indexing of the different elements in a given network:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"PVIndexes\nPQIndexes\nSlackIndexes\nGeneratorIndexes\n","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PVIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.PVIndexes","text":"PVIndexes <: AbstractIndexing\n\nIndexes of the PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.PQIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.PQIndexes","text":"PQIndexes <: AbstractIndexing\n\nIndexes of the PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.SlackIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.SlackIndexes","text":"SlackIndexes <: AbstractIndexing\n\nIndexes of the slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.GeneratorIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.GeneratorIndexes","text":"GeneratorIndexes <: AbstractIndexing\n\nIndexes of the generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#Network-values","page":"PowerSystem","title":"Network values","text":"","category":"section"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkValues","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.AbstractNetworkValues","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkValues","text":"AbstractNetworkValues\n\nNumerical values attached to the different attributes of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"List of values:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"VoltageMagnitude\nVoltageAngle\nActivePower\nReactivePower\nActiveLoad\nReactiveLoad\n","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.VoltageMagnitude","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageMagnitude","text":"VoltageMagnitude <: AbstractNetworkValues\n\nMagnitude |v| of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.VoltageAngle","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageAngle","text":"VoltageAngle <: AbstractNetworkValues\n\nAngle θ of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ActivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ActivePower","text":"ActivePower <: AbstractNetworkValues\n\nActive power P of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ReactivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ReactivePower","text":"ReactivePower <: AbstractNetworkValues\n\nReactive power Q of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ActiveLoad","page":"PowerSystem","title":"ExaPF.PowerSystem.ActiveLoad","text":"ActiveLoad <: AbstractNetworkValues\n\nActive load Pd at buses.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.ReactiveLoad","page":"PowerSystem","title":"ExaPF.PowerSystem.ReactiveLoad","text":"ReactiveLoad <: AbstractNetworkValues\n\nReactive load Qd at buses.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"Function to get the range of a given value:","category":"page"},{"location":"lib/powersystem.html","page":"PowerSystem","title":"PowerSystem","text":"bounds","category":"page"},{"location":"lib/powersystem.html#ExaPF.PowerSystem.bounds","page":"PowerSystem","title":"ExaPF.PowerSystem.bounds","text":"bounds(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute, val::AbstractNetworkValues)\n\nReturn lower and upper bounds corresponding to the admissible values of the AbstractNetworkAttribute attr.\n\nExamples\n\np_min, p_max = bounds(pf, Generator(), ActivePower())\nv_min, v_max = bounds(pf, Buses(), VoltageMagnitude())\n\n\n\n\n\n\n","category":"function"},{"location":"index.html#ExaPF","page":"Home","title":"ExaPF","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ExaPF.jl is a package to solve the power flow problem on upcoming exascale architectures. The code has been designed to be:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Portable: Targeting exascale architectures implies a focus on graphics processing units (GPUs) as these systems lack substantial computational performance through classical CPUs.\nDifferentiable: All the expressions implemented in ExaPF are fully compatible with ForwardDiff.jl, and routines are provided to extract first- and second-order derivatives to solve efficiently power flow and optimal power flow problems.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ExaPF implements a vectorized modeler for power systems, which allows to manipulate basic expressions. All expressions are fully differentiable : their first and second-order derivatives can be extracted efficiently using automatic differentiation. In addition, we leverage the packages CUDA.jl and KernelAbstractions.jl to make ExaPF portable across GPU architectures.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"quickstart.md\",\n]\nDepth=1","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/formulations.md\",\n    \"man/powersystem.md\",\n    \"man/autodiff.md\",\n    \"man/linearsolver.md\",\n    \"man/benchmark.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"lib/formulations.md\",\n    \"lib/powersystem.md\",\n    \"lib/autodiff.md\",\n    \"lib/linearsolver.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Artifact","page":"Home","title":"Artifact","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"artifact.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This research was supported by the Exascale Computing Project (17-SC-20-SC), a joint project of the U.S. Department of Energy’s Office of Science and National Nuclear Security Administration, responsible for delivering a capable exascale ecosystem, including software, applications, and hardware technology, to support the nation’s exascale computing imperative.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"CurrentModule = ExaPF.LinearSolvers","category":"page"},{"location":"lib/linearsolver.html#Linear-solvers","page":"Linear Solvers","title":"Linear solvers","text":"","category":"section"},{"location":"lib/linearsolver.html#Description","page":"Linear Solvers","title":"Description","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"ExaPF allows to solve linear systems with either direct and indirect linear algebra, both on CPU and on GPU. To solve a linear system Ax = b, ExaPF uses the function ldiv!.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"ldiv!","category":"page"},{"location":"lib/linearsolver.html#LinearAlgebra.ldiv!","page":"Linear Solvers","title":"LinearAlgebra.ldiv!","text":"ldiv!(solver, x, A, y)\nldiv!(solver, x, y)\n\nsolver::AbstractLinearSolver: linear solver to solve the system\nx::AbstractVector: Solution\nA::AbstractMatrix: Input matrix\ny::AbstractVector: RHS\n\nSolve the linear system A x = y using the algorithm specified in solver. If A is not specified, the function will used directly the factorization stored inside solver.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#Direct-solvers","page":"Linear Solvers","title":"Direct solvers","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"ExaPF wraps UMFPACK (shipped with SuiteSparse.jl) on the CPU, and CUSPARSE on CUDA device.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"DirectSolver","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.DirectSolver","page":"Linear Solvers","title":"ExaPF.LinearSolvers.DirectSolver","text":"DirectSolver <: AbstractLinearSolver\n\nSolve linear system A x = y with direct linear algebra.\n\nOn the CPU, DirectSolver uses UMFPACK to solve the linear system\nOn CUDA GPU, DirectSolver redirects the resolution to the method CUSOLVER.csrlsvqr\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#Iterative-solvers","page":"Linear Solvers","title":"Iterative solvers","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"KrylovBICGSTAB\nDQGMRES\nBICGSTAB\nEigenBICGSTAB","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.KrylovBICGSTAB","page":"Linear Solvers","title":"ExaPF.LinearSolvers.KrylovBICGSTAB","text":"KrylovBICGSTAB <: AbstractIterativeLinearSolver\nKrylovBICGSTAB(precond; verbose=0, rtol=1e-10, atol=1e-10)\n\nWrap Krylov.jl's BICGSTAB algorithm to solve iteratively the linear system A x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.DQGMRES","page":"Linear Solvers","title":"ExaPF.LinearSolvers.DQGMRES","text":"DQGMRES <: AbstractIterativeLinearSolver\nDQGMRES(precond; verbose=false, memory=4)\n\nWrap Krylov.jl's DQGMRES algorithm to solve iteratively the linear system A x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.BICGSTAB","page":"Linear Solvers","title":"ExaPF.LinearSolvers.BICGSTAB","text":"BICGSTAB <: AbstractIterativeLinearSolver\nBICGSTAB(precond; maxiter=2_000, tol=1e-8, verbose=false)\n\nCustom BICGSTAB implementation to solve iteratively the linear system A  x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.EigenBICGSTAB","page":"Linear Solvers","title":"ExaPF.LinearSolvers.EigenBICGSTAB","text":"EigenBICGSTAB <: AbstractIterativeLinearSolver\nEigenBICGSTAB(precond; maxiter=2_000, tol=1e-8, verbose=false)\n\nJulia's port of Eigen's BICGSTAB to solve iteratively the linear system A x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"ExaPF.jl is shipped with a custom BICGSTAB implementation. However, we highly recommend to use KrylovBICGSTAB instead, which has proved to be more robust.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"bicgstab\n","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.bicgstab","page":"Linear Solvers","title":"ExaPF.LinearSolvers.bicgstab","text":"bicgstab(A, b, P, xi;\n         tol=1e-8,\n         maxiter=size(A, 1),\n         verbose=false,\n         maxtol=1e20)\n\nBiCGSTAB implementation according to\n\nVan der Vorst, Henk A. \"Bi-CGSTAB: A fast and smoothly converging variant of Bi-CG for the solution of nonsymmetric linear systems.\" SIAM Journal on scientific and Statistical Computing 13, no. 2 (1992): 631-644.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"Available linear solvers can be queried with","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"list_solvers\n","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.list_solvers","page":"Linear Solvers","title":"ExaPF.LinearSolvers.list_solvers","text":"list_solvers(::KernelAbstractions.Device)\n\nList linear solvers available on current device.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver.html#Preconditioning","page":"Linear Solvers","title":"Preconditioning","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"To solve linear systems with iterative methods, ExaPF provides an implementation of a block-Jacobi preconditioner, portable on GPU.","category":"page"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"AbstractPreconditioner","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.AbstractPreconditioner","page":"Linear Solvers","title":"ExaPF.LinearSolvers.AbstractPreconditioner","text":"AbstractPreconditioner\n\nPreconditioners for the iterative solvers mostly focused on GPUs\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#Block-Jacobi-preconditioner","page":"Linear Solvers","title":"Block-Jacobi preconditioner","text":"","category":"section"},{"location":"lib/linearsolver.html","page":"Linear Solvers","title":"Linear Solvers","text":"BlockJacobiPreconditioner\nupdate","category":"page"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.BlockJacobiPreconditioner","page":"Linear Solvers","title":"ExaPF.LinearSolvers.BlockJacobiPreconditioner","text":"BlockJacobiPreconditioner\n\nOverlapping-Schwarz preconditioner.\n\nAttributes\n\nnblocks::Int64: Number of partitions or blocks.\nblocksize::Int64: Size of each block.\npartitions::Vector{Vector{Int64}}:npart` partitions stored as lists\ncupartitions: partitions transfered to the GPU\nlpartitions::Vector{Int64}`: Length of each partitions.\nculpartitions::Vector{Int64}`: Length of each partitions, on the GPU.\nblocks: Dense blocks of the block-Jacobi\ncublocks: Js transfered to the GPU\nmap: The partitions as a mapping to construct views\ncumap: cumap transferred to the GPU`\npart: Partitioning as output by Metis\ncupart: part transferred to the GPU\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver.html#ExaPF.LinearSolvers.update","page":"Linear Solvers","title":"ExaPF.LinearSolvers.update","text":"function update(J::CuSparseMatrixCSR, p)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSR format for the GPU\n\nThe dense blocks cuJs are filled from the sparse Jacobian J\nTo a batch inversion of the dense blocks using CUBLAS\nExtract the preconditioner matrix p.P from the dense blocks cuJs\n\n\n\n\n\nfunction update(J::SparseMatrixCSC, p)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSC format for the CPU\n\nNote that this implements the same algorithm as for the GPU and becomes very slow on CPU with growing number of blocks.\n\n\n\n\n\n","category":"function"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const AD = ExaPF.AD\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/autodiff.html#AutoDiff","page":"AutoDiff","title":"AutoDiff","text":"","category":"section"},{"location":"man/autodiff.html#Overview","page":"AutoDiff","title":"Overview","text":"","category":"section"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Given a set of equations F(x) = 0, the Newton-Raphson algorithm for solving nonlinear equations (see below) requires the Jacobian J = jacobian(x) of F. At each iteration a new step dx is computed by solving a linear system. In our case J is sparse and indefinite.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"    go = true\n    while(go)\n        dx .= jacobian(x)\\f(x)\n        x  .= x .- dx\n        go = norm(f(x)) < tol ? true : false\n    end","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"There are two modes of differentiation called forward/tangent or reverse/adjoint. The latter is known in machine learning as backpropagation. The forward mode generates Jacobian-vector product code tgt(x,d) = J(x) * d, while the adjoint mode generates code for the transposed Jacobian-vector product adj(x,y) = (J(x)'*y). We recommend the book Evaluating derivatives: principles and techniques of algorithmic differentiation by Griewank and Walther[1] for a more in-depth introduction to automatic differentiation. The computational complexity of both models favors the adjoint mode if the number of outputs of F is much smaller than the number of inputs size(x) >> size(F), like for example the loss functions in machine learning. However, in our case F is a multivariate vector function from mathbbR^n to mathbbR^n, where n is the number of buses.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"(Image: Jacobian coloring \\label{fig:coloring})","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"To avoid a complexity of mathcalO(n) cdot cost(F) by letting the tangent mode run over all Cartesian basis vectors of mathbbR^n, we apply the technique of Jacobian coloring to compress the sparse Jacobian J. Running the tangent mode, it allows to compute columns of the Jacobian concurrently, by combining independent columns in one Jacobian-vector evaluation (see in figure above). For sparsity detection we rely on the greedy algorithm implemented by SparseDiffTools.jl.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Given the sparsity pattern, the forward model is applied through the package ForwardDiff.jl. Given the number of Jacobian colors c we can build our dual type t1s with c directions:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"t1s{N} = ForwardDiff.Dual{Nothing,Float64, N} where N}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Note that a second-order type t2s can be created naturally by applying the same logic to t1s:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"t2s{M,N} =  ForwardDiff.Dual{Nothing,t1s{N}, M} where M, N}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Finally, this dual type can be ported to both vector types Vector and CuVector:","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"VT = Vector{Float64}\nVT = Vector{t1s{N}}}\nVT = CuVector{t1s{N}}}","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"Setting VT to either of the three types allows us to instantiate code that has been written using the broadcast operator .","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"x .= a .* b","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"or accessed in kernels written for KernelAbstractions.jl like for example the power flow equations (here in polar form):","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"@kernel function residual_kernel!(F, v_m, v_a,\n                                  ybus_re_nzval, ybus_re_colptr, ybus_re_rowval,\n                                  ybus_im_nzval, ybus_im_colptr, ybus_im_rowval,\n                                  pinj, qinj, pv, pq, nbus)\n\n    npv = size(pv, 1)\n    npq = size(pq, 1)\n\n    i = @index(Global, Linear)\n    # REAL PV: 1:npv\n    # REAL PQ: (npv+1:npv+npq)\n    # IMAG PQ: (npv+npq+1:npv+2npq)\n    fr = (i <= npv) ? pv[i] : pq[i - npv]\n    F[i] -= pinj[fr]\n    if i > npv\n        F[i + npq] -= qinj[fr]\n    end\n    @inbounds for c in ybus_re_colptr[fr]:ybus_re_colptr[fr+1]-1\n        to = ybus_re_rowval[c]\n        aij = v_a[fr] - v_a[to]\n        coef_cos = v_m[fr]*v_m[to]*ybus_re_nzval[c]\n        coef_sin = v_m[fr]*v_m[to]*ybus_im_nzval[c]\n        cos_val = cos(aij)\n        sin_val = sin(aij)\n        F[i] += coef_cos * cos_val + coef_sin * sin_val\n        if i > npv\n            F[npq + i] += coef_cos * sin_val - coef_sin * cos_val\n        end\n    end\nend","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"These two abstractions are a powerful tool that allow us to implement the forward mode in vectorized form where the number of directions or tangent components of a tangent variable are the number of Jacobian colors. We illustrate this in the figure below with a point-wise vector product x .* y","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"(Image: SIMD AD for point-wise vector product \\label{fig:simd})","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"This natural way of computing the compressed Jacobian yields a very high performing code that is portable to any vector architecture, given that a similar package like CUDA.jl exists. We note that similar packages for the Intel Compute Engine and AMD ROCm are in development called oneAPI.jl and AMDGPU.jl, respectively. We expect our package to be portable to AMD and Intel GPUs in the future.","category":"page"},{"location":"man/autodiff.html","page":"AutoDiff","title":"AutoDiff","text":"[1]: Griewank, Andreas, and Andrea Walther. Evaluating derivatives: principles and techniques of algorithmic differentiation. Society for Industrial and Applied Mathematics, 2008.","category":"page"}]
}
