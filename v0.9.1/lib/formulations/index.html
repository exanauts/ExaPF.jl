<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polar formulation · ExaPF.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ExaPF.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">Quick start</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/direct_solver/">Power flow: direct solver</a></li><li><a class="tocitem" href="../../tutorials/batch_evaluation/">Power flow: batch evaluation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/powersystem/">PowerSystem</a></li><li><a class="tocitem" href="../../man/formulations/">Polar formulation</a></li><li><a class="tocitem" href="../../man/autodiff/">AutoDiff</a></li><li><a class="tocitem" href="../../man/linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../../man/benchmark/">Benchmark</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../powersystem/">PowerSystem</a></li><li class="is-active"><a class="tocitem" href>Polar formulation</a><ul class="internal"><li><a class="tocitem" href="#Generic-templates"><span>Generic templates</span></a></li><li><a class="tocitem" href="#Structure-and-variables"><span>Structure and variables</span></a></li><li><a class="tocitem" href="#Powerflow-solver"><span>Powerflow solver</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Objective"><span>Objective</span></a></li><li class="toplevel"><a class="tocitem" href="#Composition-of-expressions"><span>Composition of expressions</span></a></li></ul></li><li><a class="tocitem" href="../autodiff/">AutoDiff</a></li><li><a class="tocitem" href="../linearsolver/">Linear Solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Polar formulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polar formulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/exanauts/ExaPF.jl/blob/main/docs/src/lib/formulations.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Polar-formulation"><a class="docs-heading-anchor" href="#Polar-formulation">Polar formulation</a><a id="Polar-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Polar-formulation" title="Permalink"></a></h1><h2 id="Generic-templates"><a class="docs-heading-anchor" href="#Generic-templates">Generic templates</a><a id="Generic-templates-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-templates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ExaPF.AbstractVariable" href="#ExaPF.AbstractVariable"><code>ExaPF.AbstractVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVariable</code></pre><p>Variables corresponding to a particular formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/templates.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.AbstractFormulation" href="#ExaPF.AbstractFormulation"><code>ExaPF.AbstractFormulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFormulation</code></pre><p>Interface between the data and the mathemical formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/templates.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.State" href="#ExaPF.State"><code>ExaPF.State</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State &lt;: AbstractVariable</code></pre><p>All variables <span>$x$</span> depending on the variables <code>Control</code> <span>$u$</span> through the non-linear equation <span>$g(x, u) = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/templates.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.Control" href="#ExaPF.Control"><code>ExaPF.Control</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Control &lt;: AbstractVariable</code></pre><p>Independent variables <span>$u$</span> used in the reduced-space formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/templates.jl#L26-L31">source</a></section></article><h2 id="Structure-and-variables"><a class="docs-heading-anchor" href="#Structure-and-variables">Structure and variables</a><a id="Structure-and-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-and-variables" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ExaPF.PolarForm" href="#ExaPF.PolarForm"><code>ExaPF.PolarForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolarForm{T, IT, VT, MT} &lt;: AbstractPolarFormulation</code></pre><p>Implement the polar formulation associated to the network&#39;s equations.</p><p>Wrap a <a href="../powersystem/#ExaPF.PowerSystem.PowerNetwork"><code>PS.PowerNetwork</code></a> network to load the data on the target device (<code>CPU()</code> and <code>CUDABackend()</code> are currently supported).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; const PS = ExaPF.PowerSystem;

julia&gt; network_data = PS.load_case(&quot;case9.m&quot;);

julia&gt; polar = PolarForm(network_data, ExaPF.CPU())
Polar formulation (instantiated on device CPU(false))
Network characteristics:
    #buses:      9  (#slack: 1  #PV: 2  #PQ: 6)
    #generators: 3
    #lines:      9
giving a mathematical formulation with:
    #controls:   5
    #states  :   14
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/polar.jl#L10-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.BlockPolarForm" href="#ExaPF.BlockPolarForm"><code>ExaPF.BlockPolarForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BlockPolarForm{T, IT, VT, MT} &lt;: AbstractFormulation</code></pre><p>Block polar formulation: duplicates <code>k</code> different polar models to evaluate them in parallel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/polar.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.load_polar" href="#ExaPF.load_polar"><code>ExaPF.load_polar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_polar(case, device=CPU(); dir=PS.EXADATA)</code></pre><p>Load a <a href="#ExaPF.PolarForm"><code>PolarForm</code></a> instance from the specified benchmark library <code>dir</code> on the target <code>device</code> (default is <code>CPU</code>). ExaPF uses two different benchmark libraries: MATPOWER (<code>dir=EXADATA</code>) and PGLIB-OPF (<code>dir=PGLIB</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;)
Polar formulation (instantiated on device CPU(false))
Network characteristics:
    #buses:      9  (#slack: 1  #PV: 2  #PQ: 6)
    #generators: 3
    #lines:      9
giving a mathematical formulation with:
    #controls:   5
    #states  :   14
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/polar.jl#L97-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.NetworkStack" href="#ExaPF.NetworkStack"><code>ExaPF.NetworkStack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NetworkStack{VT,VD,MT} &lt;: AbstractNetworkStack{VT}
NetworkStack(polar::PolarForm)
NetworkStack(nbus::Int, ngen::Int, nlines::Int, VT::Type)</code></pre><p>Store the variables associated to the polar formulation. The variables are stored in the field <code>input</code>, ordered as follows</p><pre><code class="nohighlight hljs">    input = [vmag ; vang ; pgen]</code></pre><p>The object stores also intermediate variables needed in the expression tree, such as the LKMR basis <code>ψ</code>.</p><p><strong>Notes</strong></p><p>The NetworkStack can be instantiated on the host or on the target device.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar)
21-elements NetworkStack{Vector{Float64}}

julia&gt; stack.vmag
9-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/stacks.jl#L18-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.init!" href="#ExaPF.init!"><code>ExaPF.init!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init!(polar::PolarForm, stack::NetworkStack)</code></pre><p>Set <code>stack.input</code> with the initial values specified in the base <a href="../powersystem/#ExaPF.PowerSystem.PowerNetwork"><code>PS.PowerNetwork</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/stacks.jl#L131-L137">source</a></section></article><p>The state and the control are defined as mapping:</p><article class="docstring"><header><a class="docstring-binding" id="ExaPF.mapping" href="#ExaPF.mapping"><code>ExaPF.mapping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapping(polar::PolarForm, ::Control)</code></pre><p>Return the mapping associated to the <code>Control()</code> in <a href="#ExaPF.NetworkStack"><code>NetworkStack</code></a> according to the polar formulation <code>PolarForm</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; mapu = ExaPF.mapping(polar, Control())
5-element Vector{Int64}:
  1
  2
  3
 20
 21
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/polar.jl#L124-L144">source</a></section><section><div><pre><code class="nohighlight hljs">mapping(polar::PolarForm, ::State)</code></pre><p>Return the mapping associated to the <code>State()</code> in <a href="#ExaPF.NetworkStack"><code>NetworkStack</code></a> according to the polar formulation <code>PolarForm</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; mapu = ExaPF.mapping(polar, State())
14-element Vector{Int64}:
 11
 12
 13
 14
 15
 16
 17
 18
  4
  5
  6
  7
  8
  9
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/polar.jl#L179-L208">source</a></section></article><h2 id="Powerflow-solver"><a class="docs-heading-anchor" href="#Powerflow-solver">Powerflow solver</a><a id="Powerflow-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Powerflow-solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ExaPF.run_pf" href="#ExaPF.run_pf"><code>ExaPF.run_pf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_pf(
    polar::PolarForm, stack::NetworkStack;
    rtol=1e-8, max_iter=20, verbose=0,
)</code></pre><p>Solve the power flow equations <span>$g(x, u) = 0$</span> w.r.t. the stack <span>$x$</span>, using the (<a href="#ExaPF.NewtonRaphson"><code>NewtonRaphson</code></a> algorithm. The initial state <span>$x$</span> is specified implicitly inside <code>stack</code>, with the mapping <a href="#ExaPF.mapping"><code>mapping</code></a> associated to the polar formulation. The object <code>stack</code> is modified inplace in the function.</p><p>The algorithm stops when a tolerance <code>rtol</code> or a maximum number of iterations <code>maxiter</code> is reached.</p><p><strong>Arguments</strong></p><ul><li><code>polar::AbstractFormulation</code>: formulation of the power flow equation</li><li><code>stack::NetworkStack</code>: initial values in the network</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; conv = run_pf(polar, stack);

julia&gt; conv.has_converged
true

julia&gt; conv.n_iterations
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/newton.jl#L171-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.nlsolve!" href="#ExaPF.nlsolve!"><code>ExaPF.nlsolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nlsolve!(
    algo::NewtonRaphson,
    jac::Jacobian,
    stack::NetworkStack;
    linear_solver=DirectSolver(jac.J),
    nl_buffer=NLBuffer(size(jac, 2)),
)</code></pre><p>Solve the nonlinear system of equations <span>$g(x) = 0$</span> with a <a href="#ExaPF.NewtonRaphson"><code>NewtonRaphson</code></a> algorithm. At each iteration, we update the variable <span>$x$</span> as</p><p class="math-container">\[    x_{k+1} = x_{k} - (∇g_k)^{-1} g(x_k)
\]</p><p>till <span>$\| g(x_k) \| &lt; ε_{tol}$</span></p><p>In the implementation,</p><ul><li>the function <span>$g$</span> is specified in <code>jac.func</code>,</li><li>the initial variable <span>$x_0$</span> in <code>stack::NetworkStack</code> (with mapping <code>jac.map</code>),</li><li>the Jacobian <span>$∇g$</span> is computed automatically in <code>jac</code>, with automatic differentiation.</li></ul><p>Note that <code>stack</code> is modified inplace during the iterations of algorithm.</p><p>The Jacobian <code>jac</code> should be instantied before calling this function. By default, the linear system <span>$(∇g_k)^{-1} g(x_k)$</span> is solved using a LU factorization. You can specify a different linear solver by changing the optional argument <code>linear_solver</code>.</p><p><strong>Arguments</strong></p><ul><li><code>algo::NewtonRaphon</code>: Newton-Raphson object, storing the options of the algorithm</li><li><code>jac::Jacobian</code>: Stores the function <span>$g$</span> and its Jacobian <span>$∇g$</span>. The Jacobian is updated with automatic differentiation.</li><li><code>stack::NetworkStack</code>: initial values</li><li><code>linear_solver::AbstractLinearSolver</code>: linear solver used to compute the Newton step</li><li><code>nl_buffer::NLBuffer</code>: buffer storing the residual vector and the descent direction <code>Δx</code>. Can be reused to avoid unecessary allocations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; powerflow = ExaPF.PowerFlowBalance(polar) ∘ ExaPF.PolarBasis(polar);

julia&gt; jx = ExaPF.Jacobian(polar, powerflow, State());

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; conv = ExaPF.nlsolve!(NewtonRaphson(), jx, stack);

julia&gt; conv.has_converged
true

julia&gt; conv.n_iterations
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/newton.jl#L59-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.NewtonRaphson" href="#ExaPF.NewtonRaphson"><code>ExaPF.NewtonRaphson</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewtonRaphson &lt;: AbstractNonLinearSolver</code></pre><p>Newton-Raphson algorithm.</p><p><strong>Attributes</strong></p><ul><li><code>maxiter::Int</code> (default 20): maximum number of iterations</li><li><code>tol::Float64</code> (default <code>1e-8</code>): tolerance of the algorithm</li><li><code>verbose::Int</code> (default <code>0</code>): verbosity level</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/newton.jl#L5-L15">source</a></section></article><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><p>The different parts of the polar formulation are implemented in the following <code>AbstractExpression</code>:</p><article class="docstring"><header><a class="docstring-binding" id="ExaPF.PolarBasis" href="#ExaPF.PolarBasis"><code>ExaPF.PolarBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PolarBasis{VI, MT} &lt;: AbstractExpression
PolarBasis(polar::AbstractPolarFormulation)</code></pre><p>Implement the LKMR nonlinear basis. Takes as input the voltage magnitudes <code>vmag</code> and the voltage angles <code>vang</code> and returns</p><p class="math-container">\[    \begin{aligned}
        &amp; \psi_\ell^C(v, \theta) = v^f  v^t  \cos(\theta_f - \theta_t) \quad \forall \ell = 1, \cdots, n_\ell \\
        &amp; \psi_\ell^S(v, \theta) = v^f  v^t  \sin(\theta_f - \theta_t) \quad \forall \ell = 1, \cdots, n_\ell \\
        &amp; \psi_k(v, \theta) = v_k^2 \quad \forall k = 1, \cdots, n_b
    \end{aligned}\]</p><p><strong>Dimension:</strong> <code>2 * n_lines + n_bus</code></p><p><strong>Complexity</strong></p><p><code>3 n_lines + n_bus</code> mul, <code>n_lines</code> <code>cos</code> and <code>n_lines</code> <code>sin</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; basis = ExaPF.PolarBasis(polar)
PolarBasis (AbstractExpression)

julia&gt; basis(stack)
27-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 0.0
 ⋮
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/functions.jl#L6-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.PowerFlowBalance" href="#ExaPF.PowerFlowBalance"><code>ExaPF.PowerFlowBalance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerFlowBalance{VT, MT}
PowerFlowBalance(polar)</code></pre><p>Implement a subset of the power injection corresponding to <span>$(p_{inj}^{pv}, p_{inj}^{pq}, q_{inj}^{pq})$</span>. The function encodes the active balance equations at PV and PQ nodes, and the reactive balance equations at PQ nodes:</p><p class="math-container">\[\begin{aligned}
    p_i &amp;= v_i \sum_{j}^{n} v_j (g_{ij}\cos{(\theta_i - \theta_j)} + b_{ij}\sin{(\theta_i - \theta_j})) \,, &amp;
    ∀ i ∈ \{PV, PQ\} \\
    q_i &amp;= v_i \sum_{j}^{n} v_j (g_{ij}\sin{(\theta_i - \theta_j)} - b_{ij}\cos{(\theta_i - \theta_j})) \,. &amp;
    ∀ i ∈ \{PQ\}
\end{aligned}\]</p><p>Require composition with <a href="#ExaPF.PolarBasis"><code>PolarBasis</code></a>.</p><p><strong>Dimension:</strong> <code>n_pv + 2 * n_pq</code></p><p><strong>Complexity</strong></p><p><code>2</code> SpMV</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; powerflow = ExaPF.PowerFlowBalance(polar) ∘ ExaPF.PolarBasis(polar);

julia&gt; round.(powerflow(stack); digits=6)
14-element Vector{Float64}:
 -1.63
 -0.85
  0.0
  0.9
  0.0
  1.0
  0.0
  1.25
 -0.167
  0.042
 -0.2835
  0.171
 -0.2275
  0.259

julia&gt; run_pf(polar, stack); # solve powerflow equations

julia&gt; isapprox(powerflow(stack), zeros(14); atol=1e-8)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/functions.jl#L345-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.VoltageMagnitudeBounds" href="#ExaPF.VoltageMagnitudeBounds"><code>ExaPF.VoltageMagnitudeBounds</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VoltageMagnitudeBounds</code></pre><p>Implement the bounds on voltage magnitudes not taken into account in the bound constraints. In the reduced space, this is associated to the the voltage magnitudes at PQ nodes:</p><p class="math-container">\[v_{pq}^♭ ≤ v_{pq} ≤ v_{pq}^♯ .\]</p><p><strong>Dimension:</strong> <code>n_pq</code></p><p><strong>Complexity</strong></p><p><code>1</code> copyto</p><p><strong>Note</strong></p><p>In the reduced space, the constraints on the voltage magnitudes at PV nodes <span>$v_{pv}$</span> are taken into account when bounding the control <span>$u$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; voltage_pq = ExaPF.VoltageMagnitudeBounds(polar);

julia&gt; voltage_pq(stack)
6-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/functions.jl#L467-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.PowerGenerationBounds" href="#ExaPF.PowerGenerationBounds"><code>ExaPF.PowerGenerationBounds</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerGenerationBounds{VT, MT}
PowerGenerationBounds(polar)</code></pre><p>Constraints on the active power productions and on the reactive power productions that are not already taken into account in the bound constraints. In the reduced space, that amounts to</p><p class="math-container">\[p_{g,ref}^♭ ≤ p_{g,ref} ≤ p_{g,ref}^♯  ;
C_g q_g^♭ ≤ C_g q_g ≤ C_g q_g^♯  .\]</p><p>Require composition with <a href="#ExaPF.PolarBasis"><code>PolarBasis</code></a>.</p><p><strong>Dimension:</strong> <code>n_pv + 2 n_ref</code></p><p><strong>Complexity</strong></p><p><code>1</code> copyto, <code>1</code> SpMV</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; run_pf(polar, stack); # solve powerflow equations

julia&gt; power_generators = ExaPF.PowerGenerationBounds(polar) ∘ ExaPF.PolarBasis(polar);

julia&gt; round.(power_generators(stack); digits=6)
4-element Vector{Float64}:
  0.719547
  0.24069
  0.144601
 -0.03649
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/functions.jl#L545-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.LineFlows" href="#ExaPF.LineFlows"><code>ExaPF.LineFlows</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LineFlows{VT, MT}
LineFlows(polar)</code></pre><p>Implement thermal limit constraints on the lines of the network.</p><p>Require composition with <a href="#ExaPF.PolarBasis"><code>PolarBasis</code></a>.</p><p><strong>Dimension:</strong> <code>2 * n_lines</code></p><p><strong>Complexity</strong></p><p><code>4</code> SpMV, <code>4 * n_lines</code> quadratic, <code>2 * n_lines</code> add</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; run_pf(polar, stack); # solve powerflow equations

julia&gt; line_flows = ExaPF.LineFlows(polar) ∘ ExaPF.PolarBasis(polar);

julia&gt; round.(line_flows(stack); digits=6)
18-element Vector{Float64}:
 0.575679
 0.094457
 0.379983
 0.723832
 0.060169
 0.588673
 2.657418
 0.748943
 0.295351
 0.560817
 0.112095
 0.38625
 0.728726
 0.117191
 0.585164
 2.67781
 0.726668
 0.215497
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/functions.jl#L653-L699">source</a></section></article><h2 id="Objective"><a class="docs-heading-anchor" href="#Objective">Objective</a><a id="Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Objective" title="Permalink"></a></h2><p>The production costs is given in the <code>AbstractExpression</code> <code>CostFunction</code>:</p><article class="docstring"><header><a class="docstring-binding" id="ExaPF.CostFunction" href="#ExaPF.CostFunction"><code>ExaPF.CostFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CostFunction{VT, MT} &lt;: AutoDiff.AbstractExpression
CostFunction(polar)</code></pre><p>Implement the quadratic cost function for OPF</p><p class="math-container">\[    ∑_{g=1}^{n_g} c_{2,g} p_g^2 + c_{1,g} p_g + c_{0,g}\]</p><p>Require composition with <a href="#ExaPF.PolarBasis"><code>PolarBasis</code></a> to evaluate the cost of the reference generator.</p><p><strong>Dimension:</strong> <code>1</code></p><p><strong>Complexity</strong></p><p><code>1</code> SpMV, <code>1</code> <code>sum</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; cost = ExaPF.CostFunction(polar) ∘ ExaPF.PolarBasis(polar);

julia&gt; cost(stack)
1-element Vector{Float64}:
 4509.0275
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/functions.jl#L212-L241">source</a></section></article><h1 id="Composition-of-expressions"><a class="docs-heading-anchor" href="#Composition-of-expressions">Composition of expressions</a><a id="Composition-of-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Composition-of-expressions" title="Permalink"></a></h1><p>The different expressions can be combined together in several different ways.</p><article class="docstring"><header><a class="docstring-binding" id="ExaPF.MultiExpressions" href="#ExaPF.MultiExpressions"><code>ExaPF.MultiExpressions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiExpressions &lt;: AbstractExpression</code></pre><p>Implement expressions concatenation. Takes as input a vector of expressions <code>[expr1,...,exprN]</code> and concatenate them in a single expression <code>mexpr</code>, such that</p><pre><code class="nohighlight hljs">    mexpr(x) = [expr1(x) ; expr2(x) ; ... ; exprN(x)]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/functions.jl#L808-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExaPF.ComposedExpressions" href="#ExaPF.ComposedExpressions"><code>ExaPF.ComposedExpressions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComposedExpressions{Expr1&lt;:PolarBasis, Expr2} &lt;: AbstractExpression</code></pre><p>Implement expression composition. Takes as input two expressions <code>expr1</code> and <code>expr2</code> and returns a composed expression <code>cexpr</code> such that ```     cexpr(x) = expr2 ∘ expr1(x)</p><p><strong>Notes</strong></p><p>Currently, only <a href="#ExaPF.PolarBasis"><code>PolarBasis</code></a> is supported for <code>expr1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/44aaabef921f2d63ba1dbe653f251d35705a111e/src/Polar/functions.jl#L871-L882">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powersystem/">« PowerSystem</a><a class="docs-footer-nextpage" href="../autodiff/">AutoDiff »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 16 May 2023 03:22">Tuesday 16 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
