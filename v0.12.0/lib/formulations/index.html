<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polar formulation · ExaPF.jl</title><meta name="title" content="Polar formulation · ExaPF.jl"/><meta property="og:title" content="Polar formulation · ExaPF.jl"/><meta property="twitter:title" content="Polar formulation · ExaPF.jl"/><meta name="description" content="Documentation for ExaPF.jl."/><meta property="og:description" content="Documentation for ExaPF.jl."/><meta property="twitter:description" content="Documentation for ExaPF.jl."/><meta property="og:url" content="https://exanauts.github.io/ExaPF.jl/stable/lib/formulations/"/><meta property="twitter:url" content="https://exanauts.github.io/ExaPF.jl/stable/lib/formulations/"/><link rel="canonical" href="https://exanauts.github.io/ExaPF.jl/stable/lib/formulations/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ExaPF.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quickstart/">Quick start</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/direct_solver/">Power flow: direct solver</a></li><li><a class="tocitem" href="../../tutorials/batch_evaluation/">Power flow: batch evaluation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/powersystem/">PowerSystem</a></li><li><a class="tocitem" href="../../man/formulations/">Polar formulation</a></li><li><a class="tocitem" href="../../man/autodiff/">AutoDiff</a></li><li><a class="tocitem" href="../../man/linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../../man/benchmark/">Benchmark</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../powersystem/">PowerSystem</a></li><li class="is-active"><a class="tocitem" href>Polar formulation</a><ul class="internal"><li><a class="tocitem" href="#Generic-templates"><span>Generic templates</span></a></li><li><a class="tocitem" href="#Structure-and-variables"><span>Structure and variables</span></a></li><li><a class="tocitem" href="#Powerflow-solver"><span>Powerflow solver</span></a></li><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li><a class="tocitem" href="#Objective"><span>Objective</span></a></li><li class="toplevel"><a class="tocitem" href="#Composition-of-expressions"><span>Composition of expressions</span></a></li></ul></li><li><a class="tocitem" href="../autodiff/">AutoDiff</a></li><li><a class="tocitem" href="../linearsolver/">Linear Solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Polar formulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polar formulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/exanauts/ExaPF.jl/blob/main/docs/src/lib/formulations.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Polar-formulation"><a class="docs-heading-anchor" href="#Polar-formulation">Polar formulation</a><a id="Polar-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Polar-formulation" title="Permalink"></a></h1><h2 id="Generic-templates"><a class="docs-heading-anchor" href="#Generic-templates">Generic templates</a><a id="Generic-templates-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-templates" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ExaPF.AbstractVariable"><a class="docstring-binding" href="#ExaPF.AbstractVariable"><code>ExaPF.AbstractVariable</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractVariable</code></pre><p>Variables corresponding to a particular formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/templates.jl#LL10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.AbstractFormulation"><a class="docstring-binding" href="#ExaPF.AbstractFormulation"><code>ExaPF.AbstractFormulation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractFormulation</code></pre><p>Interface between the data and the mathemical formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/templates.jl#LL2-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.State"><a class="docstring-binding" href="#ExaPF.State"><code>ExaPF.State</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">State &lt;: AbstractVariable</code></pre><p>All variables <span>$x$</span> depending on the variables <code>Control</code> <span>$u$</span> through the non-linear equation <span>$g(x, u) = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/templates.jl#LL17-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.Control"><a class="docstring-binding" href="#ExaPF.Control"><code>ExaPF.Control</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Control &lt;: AbstractVariable</code></pre><p>Independent variables <span>$u$</span> used in the reduced-space formulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/templates.jl#LL26-L31">source</a></section></details></article><h2 id="Structure-and-variables"><a class="docs-heading-anchor" href="#Structure-and-variables">Structure and variables</a><a id="Structure-and-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-and-variables" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ExaPF.PolarForm"><a class="docstring-binding" href="#ExaPF.PolarForm"><code>ExaPF.PolarForm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolarForm{T, IT, VT, MT} &lt;: AbstractPolarFormulation</code></pre><p>Implement the polar formulation associated to the network&#39;s equations.</p><p>Wrap a <a href="../powersystem/#ExaPF.PowerSystem.PowerNetwork"><code>PS.PowerNetwork</code></a> network to load the data on the target backend (<code>CPU()</code> and <code>CUDABackend()</code> are currently supported).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; const PS = ExaPF.PowerSystem;

julia&gt; network_data = PS.load_case(&quot;case9.m&quot;);

julia&gt; polar = PolarForm(network_data, ExaPF.CPU())
Polar formulation (instantiated on backend CPU(false))
Network characteristics:
    #buses:      9  (#slack: 1  #PV: 2  #PQ: 6)
    #generators: 3
    #lines:      9
giving a mathematical formulation with:
    #controls:   5
    #states  :   14
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/polar.jl#LL10-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.BlockPolarForm"><a class="docstring-binding" href="#ExaPF.BlockPolarForm"><code>ExaPF.BlockPolarForm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BlockPolarForm{T, IT, VT, MT} &lt;: AbstractFormulation</code></pre><p>Block polar formulation: duplicates <code>k</code> different polar models to evaluate them in parallel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/polar.jl#LL53-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.load_polar"><a class="docstring-binding" href="#ExaPF.load_polar"><code>ExaPF.load_polar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">load_polar(case, backend=CPU(); dir=PS.EXADATA)</code></pre><p>Load a <a href="#ExaPF.PolarForm"><code>PolarForm</code></a> instance from the specified benchmark library <code>dir</code> on the target <code>backend</code> (default is <code>CPU</code>). ExaPF uses two different benchmark libraries: MATPOWER (<code>dir=EXADATA</code>) and PGLIB-OPF (<code>dir=PGLIB</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;)
Polar formulation (instantiated on backend CPU(false))
Network characteristics:
    #buses:      9  (#slack: 1  #PV: 2  #PQ: 6)
    #generators: 3
    #lines:      9
giving a mathematical formulation with:
    #controls:   5
    #states  :   14
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/polar.jl#LL99-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.NetworkStack"><a class="docstring-binding" href="#ExaPF.NetworkStack"><code>ExaPF.NetworkStack</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NetworkStack{VT,VD,MT} &lt;: AbstractNetworkStack{VT}
NetworkStack(polar::PolarForm)
NetworkStack(nbus::Int, ngen::Int, nlines::Int, VT::Type)</code></pre><p>Store the variables associated to the polar formulation. The variables are stored in the field <code>input</code>, ordered as follows</p><pre><code class="nohighlight hljs">    input = [vmag ; vang ; pgen]</code></pre><p>The object stores also intermediate variables needed in the expression tree, such as the LKMR basis <code>ψ</code>.</p><p><strong>Notes</strong></p><p>The NetworkStack can be instantiated on the host or on the target backend.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar)
21-elements NetworkStack{Vector{Float64}}

julia&gt; stack.vmag
9-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/stacks.jl#LL18-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.init!"><a class="docstring-binding" href="#ExaPF.init!"><code>ExaPF.init!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">init!(polar::PolarForm, stack::NetworkStack)</code></pre><p>Set <code>stack.input</code> with the initial values specified in the base <a href="../powersystem/#ExaPF.PowerSystem.PowerNetwork"><code>PS.PowerNetwork</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/stacks.jl#LL138-L144">source</a></section></details></article><p>The state and the control are defined as mapping:</p><article><details class="docstring" open="true"><summary id="ExaPF.mapping"><a class="docstring-binding" href="#ExaPF.mapping"><code>ExaPF.mapping</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mapping(polar::PolarForm, ::Control)</code></pre><p>Return the mapping associated to the <code>Control()</code> in <a href="#ExaPF.NetworkStack"><code>NetworkStack</code></a> according to the polar formulation <code>PolarForm</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; mapu = ExaPF.mapping(polar, Control())
5-element Vector{Int64}:
  1
  2
  3
 20
 21
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/polar.jl#LL126-L146">source</a></section><section><div><pre><code class="language-julia hljs">mapping(polar::PolarForm, ::State)</code></pre><p>Return the mapping associated to the <code>State()</code> in <a href="#ExaPF.NetworkStack"><code>NetworkStack</code></a> according to the polar formulation <code>PolarForm</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; mapu = ExaPF.mapping(polar, State())
14-element Vector{Int64}:
 11
 12
 13
 14
 15
 16
 17
 18
  4
  5
  6
  7
  8
  9
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/polar.jl#LL181-L210">source</a></section></details></article><h2 id="Powerflow-solver"><a class="docs-heading-anchor" href="#Powerflow-solver">Powerflow solver</a><a id="Powerflow-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Powerflow-solver" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ExaPF.PowerFlowProblem"><a class="docstring-binding" href="#ExaPF.PowerFlowProblem"><code>ExaPF.PowerFlowProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowProblem</code></pre><p>A mutable struct representing a power flow problem.</p><p><strong>Fields</strong></p><ul><li><code>form::AbstractFormulation</code>: The problem formulation (e.g., PolarForm, BlockPolarForm)</li><li><code>stack::AbstractNetworkStack</code>: Stack containing network variables and parameters</li><li><code>powerflow::AD.AbstractExpression</code>: Power flow balance expression</li><li><code>linear_solver::LS.AbstractLinearSolver</code>: Linear solver for Newton-Raphson iterations</li><li><code>non_linear_solver::AbstractNonLinearSolver</code>: Non-linear solver configuration</li><li><code>mapx::Vector{Int}</code>: Mapping indices for state variables</li><li><code>jac::AD.AbstractJacobian</code>: Jacobian matrix for automatic differentiation</li><li><code>conv::ConvergenceStatus</code>: Convergence status of the solver</li><li><code>backend::KA.Backend</code>: Computation backend (CPU or GPU)</li></ul><p><strong>See also</strong></p><p><a href="#ExaPF.run_pf"><code>run_pf</code></a>, <a href="#ExaPF.solve!"><code>solve!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL40-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.run_pf"><a class="docstring-binding" href="#ExaPF.run_pf"><code>ExaPF.run_pf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">run_pf(
    polar::PolarForm, stack::NetworkStack;
    rtol=1e-8, max_iter=20, verbose=0,
)</code></pre><p>Solve the power flow equations <span>$g(x, u) = 0$</span> w.r.t. the stack <span>$x$</span>, using the (<a href="#ExaPF.NewtonRaphson"><code>NewtonRaphson</code></a> algorithm. The initial state <span>$x$</span> is specified implicitly inside <code>stack</code>, with the mapping <a href="#ExaPF.mapping"><code>mapping</code></a> associated to the polar formulation. The object <code>stack</code> is modified inplace in the function.</p><p>The algorithm stops when a tolerance <code>rtol</code> or a maximum number of iterations <code>maxiter</code> is reached.</p><p><strong>Arguments</strong></p><ul><li><code>polar::AbstractFormulation</code>: formulation of the power flow equation</li><li><code>stack::NetworkStack</code>: initial values in the network</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; conv = run_pf(polar, stack);

julia&gt; conv.has_converged
true

julia&gt; conv.n_iterations
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/newton.jl#LL188-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.solve!"><a class="docstring-binding" href="#ExaPF.solve!"><code>ExaPF.solve!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve!(prob::PowerFlowProblem)</code></pre><p>Re-solve an existing power flow problem.</p><p>This function re-runs the non-linear solver on the problem, which is useful after modifying problem parameters (e.g., via <code>set_active_load!</code> or <code>set_reactive_load!</code>).</p><p><strong>Arguments</strong></p><ul><li><code>prob::PowerFlowProblem</code>: The power flow problem to solve</li></ul><p><strong>Returns</strong></p><ul><li>Convergence status of the solver</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create and solve initial problem
prob = PowerFlowProblem(&quot;case9.m&quot;, CPU(), :polar)
solve!(prob)

# Modify parameters and re-solve
set_active_load!(prob, ones(9) * 0.8)
solve!(prob)</code></pre><p><strong>See also</strong></p><p><a href="#ExaPF.run_pf"><code>run_pf</code></a>, <a href="#ExaPF.set_active_load!"><code>set_active_load!</code></a>, <a href="#ExaPF.set_reactive_load!"><code>set_reactive_load!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL372-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.nlsolve!"><a class="docstring-binding" href="#ExaPF.nlsolve!"><code>ExaPF.nlsolve!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nlsolve!(
    algo::NewtonRaphson,
    jac::Jacobian,
    stack::NetworkStack;
    linear_solver=DirectSolver(jac.J),
    nl_buffer=NLBuffer(size(jac, 2)),
)</code></pre><p>Solve the nonlinear system of equations <span>$g(x) = 0$</span> with a <a href="#ExaPF.NewtonRaphson"><code>NewtonRaphson</code></a> algorithm. At each iteration, we update the variable <span>$x$</span> as</p><p class="math-container">\[    x_{k+1} = x_{k} - (∇g_k)^{-1} g(x_k)
\]</p><p>till <span>$\| g(x_k) \| &lt; ε_{tol}$</span></p><p>In the implementation,</p><ul><li>the function <span>$g$</span> is specified in <code>jac.func</code>,</li><li>the initial variable <span>$x_0$</span> in <code>stack::NetworkStack</code> (with mapping <code>jac.map</code>),</li><li>the Jacobian <span>$∇g$</span> is computed automatically in <code>jac</code>, with automatic differentiation.</li></ul><p>Note that <code>stack</code> is modified inplace during the iterations of algorithm.</p><p>The Jacobian <code>jac</code> should be instantied before calling this function. By default, the linear system <span>$(∇g_k)^{-1} g(x_k)$</span> is solved using a LU factorization. You can specify a different linear solver by changing the optional argument <code>linear_solver</code>.</p><p><strong>Arguments</strong></p><ul><li><code>algo::NewtonRaphon</code>: Newton-Raphson object, storing the options of the algorithm</li><li><code>jac::Jacobian</code>: Stores the function <span>$g$</span> and its Jacobian <span>$∇g$</span>. The Jacobian is updated with automatic differentiation.</li><li><code>stack::NetworkStack</code>: initial values</li><li><code>linear_solver::AbstractLinearSolver</code>: linear solver used to compute the Newton step</li><li><code>nl_buffer::NLBuffer</code>: buffer storing the residual vector and the descent direction <code>Δx</code>. Can be reused to avoid unecessary allocations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; powerflow = ExaPF.PowerFlowBalance(polar) ∘ ExaPF.Basis(polar);

julia&gt; jx = ExaPF.Jacobian(polar, powerflow, State());

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; conv = ExaPF.nlsolve!(NewtonRaphson(), jx, stack);

julia&gt; conv.has_converged
true

julia&gt; conv.n_iterations
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/newton.jl#LL62-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.NewtonRaphson"><a class="docstring-binding" href="#ExaPF.NewtonRaphson"><code>ExaPF.NewtonRaphson</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NewtonRaphson &lt;: AbstractNonLinearSolver</code></pre><p>Newton-Raphson algorithm.</p><p><strong>Attributes</strong></p><ul><li><code>maxiter::Int</code> (default 20): maximum number of iterations</li><li><code>tol::Float64</code> (default <code>1e-8</code>): tolerance of the algorithm</li><li><code>verbose::Int</code> (default <code>0</code>): verbosity level</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/newton.jl#LL5-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.get_active_load"><a class="docstring-binding" href="#ExaPF.get_active_load"><code>ExaPF.get_active_load</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_active_load(prob::PowerFlowProblem)</code></pre><p>Get the active power demand (Pd) values from the power flow problem.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PowerFlowProblem</code>: The power flow problem instance</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Active power demand values for all buses in the system</li></ul><p><strong>See also</strong></p><p><a href="#ExaPF.get_reactive_load"><code>get_reactive_load</code></a>, <a href="#ExaPF.set_active_load!"><code>set_active_load!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL158-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.get_reactive_load"><a class="docstring-binding" href="#ExaPF.get_reactive_load"><code>ExaPF.get_reactive_load</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_reactive_load(prob::PowerFlowProblem)</code></pre><p>Get the reactive power demand (Qd) values from the power flow problem.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PowerFlowProblem</code>: The power flow problem instance</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Reactive power demand values for all buses in the system</li></ul><p><strong>See also</strong></p><p><a href="#ExaPF.get_active_load"><code>get_active_load</code></a>, <a href="#ExaPF.set_reactive_load!"><code>set_reactive_load!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL174-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.set_active_load!"><a class="docstring-binding" href="#ExaPF.set_active_load!"><code>ExaPF.set_active_load!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_active_load!(prob::PowerFlowProblem, pd::Vector{Float64})</code></pre><p>Set the active power demand (Pd) values for the power flow problem.</p><p>This function modifies the problem in-place, updating the active power demand parameters in the network stack.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PowerFlowProblem</code>: The power flow problem instance to modify</li><li><code>pd::Vector{Float64}</code>: New active power demand values for all buses</li></ul><p><strong>Returns</strong></p><ul><li><code>PowerFlowProblem</code>: The modified problem instance</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If the length of <code>pd</code> does not match the number of buses</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">prob = PowerFlowProblem(&quot;case9.m&quot;, CPU(), :polar)
pd_new = ones(9) * 0.5  # Set all buses to 0.5 p.u.
set_active_load!(prob, pd_new)</code></pre><p><strong>See also</strong></p><p><a href="#ExaPF.set_reactive_load!"><code>set_reactive_load!</code></a>, <a href="#ExaPF.get_active_load"><code>get_active_load</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL190-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.set_reactive_load!"><a class="docstring-binding" href="#ExaPF.set_reactive_load!"><code>ExaPF.set_reactive_load!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_reactive_load!(prob::PowerFlowProblem, qd::Vector{Float64})</code></pre><p>Set the reactive power demand (Qd) values for the power flow problem.</p><p>This function modifies the problem in-place, updating the reactive power demand parameters in the network stack.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PowerFlowProblem</code>: The power flow problem instance to modify</li><li><code>qd::Vector{Float64}</code>: New reactive power demand values for all buses</li></ul><p><strong>Returns</strong></p><ul><li><code>PowerFlowProblem</code>: The modified problem instance</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If the length of <code>qd</code> does not match the number of buses</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">prob = PowerFlowProblem(&quot;case9.m&quot;, CPU(), :polar)
qd_new = ones(9) * 0.2  # Set all buses to 0.2 p.u.
set_reactive_load!(prob, qd_new)</code></pre><p><strong>See also</strong></p><p><a href="#ExaPF.set_active_load!"><code>set_active_load!</code></a>, <a href="#ExaPF.get_reactive_load"><code>get_reactive_load</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL224-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.get_voltage_magnitude"><a class="docstring-binding" href="#ExaPF.get_voltage_magnitude"><code>ExaPF.get_voltage_magnitude</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_voltage_magnitude(prob::PowerFlowProblem)</code></pre><p>Get the voltage magnitude values from the power flow problem solution.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PowerFlowProblem</code>: The power flow problem instance</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Voltage magnitude values (in per-unit) for all buses in the system</li></ul><p><strong>See also</strong></p><p><a href="#ExaPF.get_voltage_angle"><code>get_voltage_angle</code></a>, <a href="#ExaPF.get_solution"><code>get_solution</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL278-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.get_voltage_angle"><a class="docstring-binding" href="#ExaPF.get_voltage_angle"><code>ExaPF.get_voltage_angle</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_voltage_angle(prob::PowerFlowProblem)</code></pre><p>Get the voltage angle values from the power flow problem solution.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PowerFlowProblem</code>: The power flow problem instance</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Voltage angle values (in radians) for all buses in the system</li></ul><p><strong>See also</strong></p><p><a href="#ExaPF.get_voltage_magnitude"><code>get_voltage_magnitude</code></a>, <a href="#ExaPF.get_solution"><code>get_solution</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL262-L275">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.get_solution"><a class="docstring-binding" href="#ExaPF.get_solution"><code>ExaPF.get_solution</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_solution(prob::PowerFlowProblem)</code></pre><p>Get the complete solution vector from the power flow problem.</p><p>This function returns the state variables (voltage angles and magnitudes) that were solved by the Newton-Raphson method, in the order specified by the mapping indices.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PowerFlowProblem</code>: The power flow problem instance</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Solution vector containing the state variables</li></ul><p><strong>See also</strong></p><p><a href="#ExaPF.get_voltage_angle"><code>get_voltage_angle</code></a>, <a href="#ExaPF.get_voltage_magnitude"><code>get_voltage_magnitude</code></a>, <a href="#ExaPF.solve!"><code>solve!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/ExaPF.jl#LL294-L311">source</a></section></details></article><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><p>The different parts of the polar formulation are implemented in the following <code>AbstractExpression</code>:</p><article><details class="docstring" open="true"><summary id="ExaPF.Basis"><a class="docstring-binding" href="#ExaPF.Basis"><code>ExaPF.Basis</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Basis{VI, MT} &lt;: AbstractExpression
Basis(polar::AbstractPolarFormulation)</code></pre><p>Implement the LKMR nonlinear basis. Takes as input the voltage magnitudes <code>vmag</code> and the voltage angles <code>vang</code> and returns</p><p class="math-container">\[    \begin{aligned}
        &amp; \psi_\ell^C(v, \theta) = v^f  v^t  \cos(\theta_f - \theta_t) \quad \forall \ell = 1, \cdots, n_\ell \\
        &amp; \psi_\ell^S(v, \theta) = v^f  v^t  \sin(\theta_f - \theta_t) \quad \forall \ell = 1, \cdots, n_\ell \\
        &amp; \psi_k(v, \theta) = v_k^2 \quad \forall k = 1, \cdots, n_b
    \end{aligned}\]</p><p><strong>Dimension:</strong> <code>2 * n_lines + n_bus</code></p><p><strong>Complexity</strong></p><p><code>3 n_lines + n_bus</code> mul, <code>n_lines</code> <code>cos</code> and <code>n_lines</code> <code>sin</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; basis = ExaPF.Basis(polar)
Basis (AbstractExpression)

julia&gt; basis(stack)
27-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 0.0
 ⋮
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/functions.jl#LL6-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.PowerFlowBalance"><a class="docstring-binding" href="#ExaPF.PowerFlowBalance"><code>ExaPF.PowerFlowBalance</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowBalance{VT, MT}
PowerFlowBalance(polar)</code></pre><p>Implement a subset of the power injection corresponding to <span>$(p_{inj}^{pv}, p_{inj}^{pq}, q_{inj}^{pq})$</span>. The function encodes the active balance equations at PV and PQ nodes, and the reactive balance equations at PQ nodes:</p><p class="math-container">\[\begin{aligned}
    p_i &amp;= v_i \sum_{j}^{n} v_j (g_{ij}\cos{(\theta_i - \theta_j)} + b_{ij}\sin{(\theta_i - \theta_j})) \,, &amp;
    ∀ i ∈ \{PV, PQ\} \\
    q_i &amp;= v_i \sum_{j}^{n} v_j (g_{ij}\sin{(\theta_i - \theta_j)} - b_{ij}\cos{(\theta_i - \theta_j})) \,. &amp;
    ∀ i ∈ \{PQ\}
\end{aligned}\]</p><p>Require composition with <a href="#ExaPF.Basis"><code>Basis</code></a>.</p><p><strong>Dimension:</strong> <code>n_pv + 2 * n_pq</code></p><p><strong>Complexity</strong></p><p><code>2</code> SpMV</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; powerflow = ExaPF.PowerFlowBalance(polar) ∘ ExaPF.Basis(polar);

julia&gt; round.(powerflow(stack); digits=6)
14-element Vector{Float64}:
 -1.63
 -0.85
  0.0
  0.9
  0.0
  1.0
  0.0
  1.25
 -0.167
  0.042
 -0.2835
  0.171
 -0.2275
  0.259

julia&gt; run_pf(polar, stack); # solve powerflow equations

julia&gt; isapprox(powerflow(stack), zeros(14); atol=1e-8)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/functions.jl#LL345-L401">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.VoltageMagnitudeBounds"><a class="docstring-binding" href="#ExaPF.VoltageMagnitudeBounds"><code>ExaPF.VoltageMagnitudeBounds</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoltageMagnitudeBounds</code></pre><p>Implement the bounds on voltage magnitudes not taken into account in the bound constraints. In the reduced space, this is associated to the the voltage magnitudes at PQ nodes:</p><p class="math-container">\[v_{pq}^♭ ≤ v_{pq} ≤ v_{pq}^♯ .\]</p><p><strong>Dimension:</strong> <code>n_pq</code></p><p><strong>Complexity</strong></p><p><code>1</code> copyto</p><p><strong>Note</strong></p><p>In the reduced space, the constraints on the voltage magnitudes at PV nodes <span>$v_{pv}$</span> are taken into account when bounding the control <span>$u$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; voltage_pq = ExaPF.VoltageMagnitudeBounds(polar);

julia&gt; voltage_pq(stack)
6-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/functions.jl#LL467-L506">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.PowerGenerationBounds"><a class="docstring-binding" href="#ExaPF.PowerGenerationBounds"><code>ExaPF.PowerGenerationBounds</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PowerGenerationBounds{VT, MT}
PowerGenerationBounds(polar)</code></pre><p>Constraints on the active power productions and on the reactive power productions that are not already taken into account in the bound constraints. In the reduced space, that amounts to</p><p class="math-container">\[p_{g,ref}^♭ ≤ p_{g,ref} ≤ p_{g,ref}^♯  ;
C_g q_g^♭ ≤ C_g q_g ≤ C_g q_g^♯  .\]</p><p>Require composition with <a href="#ExaPF.Basis"><code>Basis</code></a>.</p><p><strong>Dimension:</strong> <code>n_pv + 2 n_ref</code></p><p><strong>Complexity</strong></p><p><code>1</code> copyto, <code>1</code> SpMV</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; run_pf(polar, stack); # solve powerflow equations

julia&gt; power_generators = ExaPF.PowerGenerationBounds(polar) ∘ ExaPF.Basis(polar);

julia&gt; round.(power_generators(stack); digits=6)
4-element Vector{Float64}:
  0.719547
  0.24069
  0.144601
 -0.03649
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/functions.jl#LL545-L583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.LineFlows"><a class="docstring-binding" href="#ExaPF.LineFlows"><code>ExaPF.LineFlows</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LineFlows{VT, MT}
LineFlows(polar)</code></pre><p>Implement thermal limit constraints on the lines of the network.</p><p>Require composition with <a href="#ExaPF.Basis"><code>Basis</code></a>.</p><p><strong>Dimension:</strong> <code>2 * n_lines</code></p><p><strong>Complexity</strong></p><p><code>4</code> SpMV, <code>4 * n_lines</code> quadratic, <code>2 * n_lines</code> add</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; run_pf(polar, stack); # solve powerflow equations

julia&gt; line_flows = ExaPF.LineFlows(polar) ∘ ExaPF.Basis(polar);

julia&gt; round.(line_flows(stack); digits=6)
18-element Vector{Float64}:
 0.575679
 0.094457
 0.379983
 0.723832
 0.060169
 0.588673
 2.657418
 0.748943
 0.295351
 0.560817
 0.112095
 0.38625
 0.728726
 0.117191
 0.585164
 2.67781
 0.726668
 0.215497
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/functions.jl#LL653-L699">source</a></section></details></article><h2 id="Objective"><a class="docs-heading-anchor" href="#Objective">Objective</a><a id="Objective-1"></a><a class="docs-heading-anchor-permalink" href="#Objective" title="Permalink"></a></h2><p>The production costs is given in the <code>AbstractExpression</code> <code>CostFunction</code>:</p><article><details class="docstring" open="true"><summary id="ExaPF.CostFunction"><a class="docstring-binding" href="#ExaPF.CostFunction"><code>ExaPF.CostFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CostFunction{VT, MT} &lt;: AutoDiff.AbstractExpression
CostFunction(polar)</code></pre><p>Implement the quadratic cost function for OPF</p><p class="math-container">\[    ∑_{g=1}^{n_g} c_{2,g} p_g^2 + c_{1,g} p_g + c_{0,g}\]</p><p>Require composition with <a href="#ExaPF.Basis"><code>Basis</code></a> to evaluate the cost of the reference generator.</p><p><strong>Dimension:</strong> <code>1</code></p><p><strong>Complexity</strong></p><p><code>1</code> SpMV, <code>1</code> <code>sum</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; polar = ExaPF.load_polar(&quot;case9&quot;);

julia&gt; stack = ExaPF.NetworkStack(polar);

julia&gt; cost = ExaPF.CostFunction(polar) ∘ ExaPF.Basis(polar);

julia&gt; cost(stack)
1-element Vector{Float64}:
 4509.0275
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/functions.jl#LL212-L241">source</a></section></details></article><h1 id="Composition-of-expressions"><a class="docs-heading-anchor" href="#Composition-of-expressions">Composition of expressions</a><a id="Composition-of-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Composition-of-expressions" title="Permalink"></a></h1><p>The different expressions can be combined together in several different ways.</p><article><details class="docstring" open="true"><summary id="ExaPF.MultiExpressions"><a class="docstring-binding" href="#ExaPF.MultiExpressions"><code>ExaPF.MultiExpressions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiExpressions &lt;: AbstractExpression</code></pre><p>Implement expressions concatenation. Takes as input a vector of expressions <code>[expr1,...,exprN]</code> and concatenate them in a single expression <code>mexpr</code>, such that</p><pre><code class="nohighlight hljs">    mexpr(x) = [expr1(x) ; expr2(x) ; ... ; exprN(x)]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/functions.jl#LL808-L820">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ExaPF.ComposedExpressions"><a class="docstring-binding" href="#ExaPF.ComposedExpressions"><code>ExaPF.ComposedExpressions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ComposedExpressions{Expr1&lt;:Basis, Expr2} &lt;: AbstractExpression</code></pre><p>Implement expression composition. Takes as input two expressions <code>expr1</code> and <code>expr2</code> and returns a composed expression <code>cexpr</code> such that ```     cexpr(x) = expr2 ∘ expr1(x)</p><p><strong>Notes</strong></p><p>Currently, only <a href="#ExaPF.Basis"><code>Basis</code></a> is supported for <code>expr1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/exanauts/ExaPF.jl/blob/92779442e83186ad0633af700bfbf9edcffdabfb/src/Polar/functions.jl#LL871-L882">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../powersystem/">« PowerSystem</a><a class="docs-footer-nextpage" href="../autodiff/">AutoDiff »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 12 December 2025 16:04">Friday 12 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
