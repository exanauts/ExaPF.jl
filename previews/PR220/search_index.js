var documenterSearchIndex = {"docs":
[{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"CurrentModule = ExaPF","category":"page"},{"location":"lib/formulations/#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"lib/formulations/#Description","page":"Formulations","title":"Description","text":"","category":"section"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"AbstractFormulation\nPolarForm\n","category":"page"},{"location":"lib/formulations/#ExaPF.AbstractFormulation","page":"Formulations","title":"ExaPF.AbstractFormulation","text":"AbstractFormulation\n\nSecond layer of the package, implementing the interface between the first layer (the topology of the network) and the third layer (implementing the callbacks for the optimization solver).\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations/#ExaPF.PolarForm","page":"Formulations","title":"ExaPF.PolarForm","text":"PolarForm{T, IT, VT, MT}\n\nWrap a PS.PowerNetwork network to load the data on the target device (CPU() and CUDADevice() are currently supported).\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations/#Powerflow-solver","page":"Formulations","title":"Powerflow solver","text":"","category":"section"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"powerflow\nNewtonRaphson\n","category":"page"},{"location":"lib/formulations/#ExaPF.NewtonRaphson","page":"Formulations","title":"ExaPF.NewtonRaphson","text":"NewtonRaphson <: AbstractNonLinearSolver\n\nNewton-Raphson algorithm.\n\nAttributes\n\nmaxiter::Int (default 20): maximum number of iterations\ntol::Float64 (default 1e-8): tolerance of the algorithm\nverbose::Int (default 0): verbosity level\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations/#Constraints","page":"Formulations","title":"Constraints","text":"","category":"section"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"Current supported constraints are:","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"voltage_magnitude_constraints\nactive_power_constraints\nreactive_power_constraints\nflow_constraints\npower_balance\nbus_power_injection\nnetwork_operations\n","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"These functions allow to query constraints' attributes:","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"is_constraint\nsize_constraint\nbounds\n","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"ExaPF implements special functions to compute the derivatives of each constraints:","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"adjoint!\njacobian_transpose_product!\nmatpower_jacobian\nmatpower_hessian\njacobian_sparsity","category":"page"},{"location":"lib/formulations/#API-Reference","page":"Formulations","title":"API Reference","text":"","category":"section"},{"location":"lib/formulations/#Variables","page":"Formulations","title":"Variables","text":"","category":"section"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"AbstractVariable\nState\nControl\nPhysicalState\n","category":"page"},{"location":"lib/formulations/#ExaPF.AbstractVariable","page":"Formulations","title":"ExaPF.AbstractVariable","text":"AbstractVariable\n\nVariables corresponding to a particular formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations/#ExaPF.State","page":"Formulations","title":"ExaPF.State","text":"State <: AbstractVariable\n\nAll variables x depending on the variables Control u through the non-linear equation g(x u) = 0.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations/#ExaPF.Control","page":"Formulations","title":"ExaPF.Control","text":"Control <: AbstractVariable\n\nIndependent variables u used in the reduced-space formulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"Get default values attached to a given variable:","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"initial\n","category":"page"},{"location":"lib/formulations/#Attributes","page":"Formulations","title":"Attributes","text":"","category":"section"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"AbstractFormAttribute\nNumberOfState\nNumberOfControl\n","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"ExaPF extends Base.get to query the different attributes of a model:","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"get\n","category":"page"},{"location":"lib/formulations/#Base.get","page":"Formulations","title":"Base.get","text":"get(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute)\n\nReturn value of attribute attr in the AbstractPowerSystem object pf.\n\nget(pf::AbstractPowerSystem, attr::AbstractIndexing)\n\nReturn indexing corresponding to a subset of the buses.\n\nExamples\n\nnpq = get(pf, NumberOfPQBuses())\nnpv = get(pf, NumberOfPVBuses())\n\n\n\n\n\n\n","category":"function"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"The associated setter is implemented with setvalues!:","category":"page"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"setvalues!","category":"page"},{"location":"lib/formulations/#Costs","page":"Formulations","title":"Costs","text":"","category":"section"},{"location":"lib/formulations/","page":"Formulations","title":"Formulations","text":"cost_production","category":"page"},{"location":"lib/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF.AutoDiff","category":"page"},{"location":"lib/autodiff/#AutoDiff","page":"AutoDiff","title":"AutoDiff","text":"","category":"section"},{"location":"lib/autodiff/#Abstract-Types","page":"AutoDiff","title":"Abstract Types","text":"","category":"section"},{"location":"lib/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"AbstractHessianProd\nAbstractFullHessian\nAbstractJacobian\nAbstractStack","category":"page"},{"location":"lib/autodiff/#ExaPF.AutoDiff.AbstractHessianProd","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractHessianProd","text":"AbstractHessianProd\n\nReturns the adjoint-Hessian-vector product λ^ H v of any nonlinear constraint h(x).\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff/#ExaPF.AutoDiff.AbstractFullHessian","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractFullHessian","text":"AbstractHessianProd\n\nFull sparse Hessian H of any nonlinear constraint h(x).\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff/#ExaPF.AutoDiff.AbstractJacobian","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractJacobian","text":"AbstractJacobian\n\nAutomatic differentiation for the compressed Jacobian of any nonlinear constraint h(x).\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff/#ExaPF.AutoDiff.AbstractStack","page":"AutoDiff","title":"ExaPF.AutoDiff.AbstractStack","text":"AbstractStack{VT}\n\nAbstract variable storing the inputs and the intermediate values in the expression tree.\n\n\n\n\n\n","category":"type"},{"location":"lib/autodiff/#AutoDiff-API","page":"AutoDiff","title":"AutoDiff API","text":"","category":"section"},{"location":"lib/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"seed!\nseed_coloring!\npartials!\nset_value!","category":"page"},{"location":"lib/autodiff/#ExaPF.AutoDiff.seed!","page":"AutoDiff","title":"ExaPF.AutoDiff.seed!","text":"seed!(\n    H::AbstractHessianProd,\n    v::AbstractVector{T},\n) where {T}\n\nSeed the duals with v to compute the Hessian vector product λ^ H v.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff/#ExaPF.AutoDiff.seed_coloring!","page":"AutoDiff","title":"ExaPF.AutoDiff.seed_coloring!","text":"seed_coloring!(\n    M::Union{AbstractJacobian, AbstractFullHessian}\n    coloring::AbstractVector,\n)\n\nSeed the duals with the coloring based seeds to compute the Jacobian or Hessian M.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff/#ExaPF.AutoDiff.partials!","page":"AutoDiff","title":"ExaPF.AutoDiff.partials!","text":"partials!(jac::AbstractJacobian)\n\nExtract partials from Jacobian jac in jac.J.\n\n\n\n\n\npartials!(hess::AbstractFullHessian)\n\nExtract partials from Hessian hess into hess.H.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff/#ExaPF.AutoDiff.set_value!","page":"AutoDiff","title":"ExaPF.AutoDiff.set_value!","text":"set_value!(\n    jac,\n    primals::AbstractVector{T}\n) where {T}\n\nSet values of ForwardDiff.Dual numbers in jac to primals.\n\n\n\n\n\n","category":"function"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const PS = ExaPF.PowerSystem\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/powersystem/#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"The main goal of ExaPF.jl is the solution of optimization problems for electrical power systems in the steady state. The first step in this process is the creation of an object that describes the physics and topology of the power system which ultimately will be mapped into an abstract mathematical optimization problem. In this section we briefly review the power system in the steady state and describe the tools to create and examine power systems in ExaPF.jl.","category":"page"},{"location":"man/powersystem/#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"The electrical power system is represented as a linear, lumped network which has to satisfy the Kirchhoff laws:","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"    bmi = bmYbmv ","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"where bmi bmv in mathbbC^N_B are the current and voltage vectors associated to the system and bmY in mathbbC^N_B times N_B is the admittance matrix. These equations are often rewritten in terms of apparent powers:","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"    bms = bmp + jbmq = textitdiag(bmv^*) bmYbmv","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"Using polar representation of the voltage vector, such as bmv = ve^j theta, each bus i=1 cdots N_B  must satisfy the power balance equations:","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"beginaligned\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j)) \nendaligned","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"where each bus i has variables p_i q_i v_i theta_i and the topology of the network is defined by a non-negative value of the admittance between two buses i and j, y_ij = g_ij + ib_ij.","category":"page"},{"location":"man/powersystem/#The-PowerNetwork-Object","page":"PowerSystem","title":"The PowerNetwork Object","text":"","category":"section"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"Currently we can create a PowerNetwork object by parsing a MATPOWER data file.","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"julia> datafile = joinpath(artifact\"ExaData\", \"ExaData\", \"case9.raw\")\njulia> ps = PowerSystem.PowerNetwork(datafile)","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"Apart of MATPOWER data file, PSSE data file are also supported (also contained in the ExaData artifact)","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"julia> datafile = joinpath(artifact\"ExaData\", \"ExaData\", \"case14.raw\")\njulia> ps = PowerSystem.PowerNetwork(datafile)","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"If we print the object, we will obtain bus information, initial voltage, and power that we read from the data file.","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"julia> println(ps)\nPower Network characteristics:\n    Buses: 9. Slack: 1. PV: 2. PQ: 6\n    Generators: 3.\n    ==============================================\n    BUS      TYPE    VMAG    VANG    P   Q\n    ==============================================\n    1     3      1.000  0.00    0.000   0.000\n    2     2      1.000  0.00    1.630   0.000\n    3     2      1.000  0.00    0.850   0.000\n    4     1      1.000  0.00    0.000   0.000\n    5     1      1.000  0.00    -0.900  -0.300\n    6     1      1.000  0.00    0.000   0.000\n    7     1      1.000  0.00    -1.000  -0.350\n    8     1      1.000  0.00    0.000   0.000\n    9     1      1.000  0.00    -1.250  -0.500","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"then, using multiple dispatch, we have defined a set of abstract data types and getter functions which allow us to retrieve information from the PowerNetwork object","category":"page"},{"location":"man/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"julia> PowerSystem.get(ps, PowerSystem.NumberOfPQBuses())\n6\njulia> PowerSystem.get(ps, PowerSystem.NumberOfPVBuses())\n2\njulia> PowerSystem.get(ps, PowerSystem.NumberOfSlackBuses())\n1","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const Precondition = ExaPF.Precondition\n    const Iterative = ExaPF.Iterative\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/linearsolver/#Linear-Solver","page":"Linear Solver","title":"Linear Solver","text":"","category":"section"},{"location":"man/linearsolver/#Overview","page":"Linear Solver","title":"Overview","text":"","category":"section"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"As mentioned before, a linear solver is required to compute the Newton step in","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"dx .= jacobian(x)\\f(x)","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"Our package supports the following linear solvers:","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"cuSOLVER with csrlsvqr (GPU),\nKrylov.jl with dqgmres and bicgstab (CPU/GPU),\nUMFPACK through the default Julia \\ operator (CPU),\ngeneric BiCGSTAB implementation [Vorst1992] (CPU/GPU),\nor any linear solver wrapped in LinearAlgebra.","category":"page"},{"location":"man/linearsolver/#Preconditioning","page":"Linear Solver","title":"Preconditioning","text":"","category":"section"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"Using only an iterative solver leads to divergence and bad performance due to ill-conditioning of the Jacobian. This is a known phenomenon in power systems. That's why this package comes with a block Jacobi preconditioner that is tailored towards GPUs and is proven to work well with power flow problems.","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"The Jacobian is partitioned into a dense block diagonal structure using Metis.jl, where each block is inverted to build our preconditioner P.","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"(Image: Dense block Jacobi preconditioner \\label{fig:preconditioner})","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"Compared to incomplete Cholesky and incomplete LU this preconditioner is easily portable to the GPU if the number of blocks is high enough. ExaPF.jl uses the batch BLAS calls from cuBLAS to invert the single blocks.","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"CUDA.@sync pivot, info = CUDA.CUBLAS.getrf_batched!(blocks, true)\nCUDA.@sync pivot, info, p.cuJs = CUDA.CUBLAS.getri_batched(blocks, pivot)","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"Assuming that other vendors will provide such batched BLAS APIs, this code is portable to other GPU architectures.","category":"page"},{"location":"man/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"[Vorst1992]: Vorst, H. A. van der. 1992. “Bi-Cgstab: A Fast and Smoothly Converging Variant of Bi-Cg for the Solution of Nonsymmetric Linear Systems.”SIAM Journal on Scientific and Statistical Computing 13 (2): 631–44","category":"page"},{"location":"artifact/#ExaData-Artifact","page":"ExaData Artifact","title":"ExaData Artifact","text":"","category":"section"},{"location":"artifact/","page":"ExaData Artifact","title":"ExaData Artifact","text":"The ExaData artifact contains test cases relevant to the Exascale Computing Project. It is built from the git repository available at ExaData. Apart from the standard MATPOWER files it additionally contains demand scenarios and contingencies used in multiperiod security constrained optimal power flow settings.","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/benchmark/#Benchmark","page":"Benchmark","title":"Benchmark","text":"","category":"section"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"For the purpose of performance regression testing, ExaPF provides a lightweight benchmark script. It allows to test the various configurations for the linear solvers used in the Newton-Raphson algorithm, and run them on a specific hardware. The main julia script benchmark/benchmarks.jl takes all its options from the command line. The benchmark script takes as input a linear solver (e.g. KrylovBICGSTAB), a target architecture as a KernelAbstractions object (CPU or CUDADevice), and a case filename which is included in the ExaData artifact. An exhaustive list of all available linear solvers can be obtained via ExaPF.LinearSolvers.list_solvers.","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"Running","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"julia --project benchmark/benchmarks.jl KrylovBICGSTAB CUDADevice case300.m","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"yields","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"KrylovBICGSTAB, CUDADevice, case300.m,  69.0,  3.57,  43.7, true","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"The first three fields are the settings of the benchmark run. They are followed by three timings in milliseconds:","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"the time taken by the Newton-Raphson algorithm to solve the power flow,\nthe timings for the Jacobian accumulation using AutoDiff,\nand the time for the linear solver, including the preconditioner.","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"To acquire these timings the code is run three times to avoid any precompilation effects. The last field confirms the Newton-Raphson convergence. In case more verbose output is desired, one has to manually set the verbosity in benchmark/benchmarks.jl by changing","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"powerflow_solver = NewtonRaphson(tol=ntol)","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"to one of the following options:","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"powerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_NONE)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_LOW)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_MEDIUM)\npowerflow_solver = NewtonRaphson(tol=ntol, verbose=VERBOSE_LEVEL_HIGH)","category":"page"},{"location":"man/benchmark/","page":"Benchmark","title":"Benchmark","text":"A shell script benchmark/benchmarks.sh is provided to gather timings with various canonical configurations and storing them in a file cpu_REV.log and gpu_REF.log, where REV is the sha1 hash of the current checked out ExaPF version.","category":"page"},{"location":"man/formulations/#Formulations","page":"Formulations","title":"Formulations","text":"","category":"section"},{"location":"man/formulations/#Overview","page":"Formulations","title":"Overview","text":"","category":"section"},{"location":"quickstart/#Quick-Start","page":"Quick start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"This page introduces the first steps to set up ExaPF.jl. We show how to load a power network instance and how to solve the power flow equations both on the CPU and on the GPU. The full script is implemented in test/quickstart.jl.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"We start by importing CUDA and KernelAbstractions:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"using CUDA\nusing KernelAbstractions\nusing CUDAKernels","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Then, we load ExaPF and its submodules with","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"using ExaPF\nimport ExaPF: AutoDiff\nconst PS = ExaPF.PowerSystem\nconst LS = ExaPF.LinearSolvers","category":"page"},{"location":"quickstart/#Short-version","page":"Quick start","title":"Short version","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"ExaPF loads instances from the pglib-opf benchmark. ExaPF contains an artifact defined in Artifacts.toml that is built from the ExaData repository containing Exascale Computing Project relevant test cases. You may set a data file using","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"datafile = joinpath(artifact\"ExaData\", \"ExaData\", \"case1354.m\")","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"using LazyArtifacts\nusing ExaPF\nusing CUDA\nusing KernelAbstractions\nusing CUDAKernels\nusing ExaPF\nimport ExaPF: AutoDiff\nconst PS = ExaPF.PowerSystem\nconst LS = ExaPF.LinearSolvers\nartifact_toml = joinpath(@__DIR__, \"..\", \"..\", \"Artifacts.toml\")\nexadata_hash = artifact_hash(\"ExaData\", artifact_toml)\ndatafile = joinpath(artifact_path(exadata_hash), \"ExaData\", \"case1354.m\")","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The powerflow equations can be solved in three lines of code, as","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"polar = ExaPF.PolarForm(datafile, CPU())\npf_algo = NewtonRaphson(; verbose=1, tol=1e-10)\nconvergence = ExaPF.powerflow(polar, pf_algo)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Implicitly, ExaPF has just proceed to the following operations:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"instantiate automatically a starting point x_0 from MATPOWER's data\ninstantiate the Jacobian of the powerflow equations using AutoDiff.\nsolve the powerflow equations iteratively, using a Newton-Raphson algorithm.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"This compact syntax allows to solve quickly any powerflow equations in a few lines a code. However, in most case, the user may want more coarse grained control on the different objects manipulated.","category":"page"},{"location":"quickstart/#Detailed-version","page":"Quick start","title":"Detailed version","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"In what follows, we detail step by step the detailed procedure to solve the powerflow equations.","category":"page"},{"location":"quickstart/#How-to-load-a-MATPOWER-instance-as-a-PowerNetwork-object?","page":"Quick start","title":"How to load a MATPOWER instance as a PowerNetwork object?","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"We start by importing a MATPOWER instance to a ExaPF.PowerSystem.PowerNetwork object:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"pf = PS.PowerNetwork(datafile)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The different fields of the object pf specify the characteristics of the network. For instance, we can retrieve the number of buses or get the indexing of the PV buses with","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"nbus = PS.get(pf, PS.NumberOfBuses())\npv_indexes = PS.get(pf, PS.PVIndexes())","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"However, a ExaPF.PowerSystem.PowerNetwork object stores only the physical attributes of the network, independently of the mathematical formulations we can use to model the network. To choose a particular formulation, we need to pass the object pf to an ExaPF.AbstractFormulation layer. Currently, the only layer implemented is the polar formulation, with the ExaPF.PolarForm structure. In the future, other formulations (e.g. RectangularForm) may be implemented as well.","category":"page"},{"location":"quickstart/#How-to-solve-the-powerflow-equations?","page":"Quick start","title":"How to solve the powerflow equations?","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"To solve the powerflow equations, we need to choose a given mathematical formulation for the equations of the network. To each formulation corresponds a given state x and control u. Using polar representation of the voltage vector, such as bmv = ve^j theta, each bus i=1 cdots N_B must satisfy the power balance equations:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n    p_i = v_i sum_j^n v_j (g_ijcos(theta_i - theta_j) + b_ijsin(theta_i - theta_j))  \n    q_i = v_i sum_j^n v_j (g_ijsin(theta_i - theta_j) - b_ijcos(theta_i - theta_j)) \nendaligned","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The powerflow equations rewrite in the abstract mathematical formalism:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"g(x u) = 0","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"For a given control u, solving the powerflow equations resumes to find a state x(u) such that g(x(u) u) = 0.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"To this goal, ExaPF.jl implements a Newton-Raphson algorithm that allows to solve the powerflow equations in a few lines of code. We first instantiate a PolarForm object to adopt a polar formulation as a model:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"polar = ExaPF.PolarForm(pf, CPU())","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Note that the constructor ExaPF.PolarForm takes as input a ExaPF.PowerSystem.PowerNetwork object and a KernelAbstractions.jl device (here set to CPU() by default). We will explain in the next section how to load a ExaPF.PolarForm object on the GPU with the help of a CUDADevice().","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The Newton-Raphson solves the equation g(x u) = 0 in an iterative fashion. The algorithm solves at each step the linear equation:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"    x_k+1 = - (nabla_x g_k)^-1 g(x_k u)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Hence, the algorithm requires the following elements:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"an initial position x_0\na function to solve efficiently the linear system (nabla_x g_k) x_k+1 = g(x_k u)\na function to evaluate the Jacobian nabla_x g_k","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"that translate to the Julia code:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"physical_state = get(polar, ExaPF.PhysicalState());\nExaPF.init_buffer!(polar, physical_state); # populate values inside buffer\nlinear_solver = LS.DirectSolver();","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"We build a Jacobian object storing all structures needed by the AutoDiff backend:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"jx = AutoDiff.Jacobian(polar, ExaPF.power_balance, State())","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Let's explain further these three objects.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"physical_state is a AbstractPhysicalCache storing all the physical values attached to the formulation polar::PolarForm.\njx is a Jacobian structure which allows the solver to compute efficiently the Jacobian of the powerflow equations nabla_x g using AutoDiff.\nlinear_solver specifies the linear algorithm uses to solve the linear system (nabla_x g_k) x_k+1 = g(x_k u). By default, we use direct linear algebra.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"In the AutoDiff Jacobian jx, the evaluation of the Jacobian J is stored in jx.J:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"jac = jx.J;","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"This matrix is at the basis of the powerflow algorithm. At each iteration, the AutoDiff backend updates the values in the Jacobian jx, then we take the updated matrix jx.J to evaluate the","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The procedure is implemented in the powerflow function, which uses a Newton-Raphson algorithm to solve the powerflow equations. The Newton-Raphson algorithm is specified as:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"pf_algo = NewtonRaphson(; verbose=1, tol=1e-10)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Then, we can solve the powerflow equations simply with","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"convergence = ExaPF.powerflow(polar, jx, physical_state, pf_algo;\n                              linear_solver=linear_solver)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Here, the algorithm solves the powerflow equations in 5 iterations. The algorithm modifies the values of physical_state inplace, to avoid any unnecessary memory allocations.","category":"page"},{"location":"quickstart/#How-to-deport-the-computation-on-the-GPU?","page":"Quick start","title":"How to deport the computation on the GPU?","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Now, how can we deport the resolution on the GPU? The procedure looks exactly the same. It suffices to initiate a new ExaPF.PolarForm object, but on the GPU:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"polar_gpu = ExaPF.PolarForm(pf, CUDADevice())\n","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"polar_gpu will load all the structures it needs on the GPU, to avoid unnecessary movements between the host and the device. We can load the other structures directly on the GPU with:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"physical_state_gpu = get(polar_gpu, ExaPF.PhysicalState());\nExaPF.init_buffer!(polar_gpu, physical_state_gpu); # populate values inside buffer\njx_gpu = AutoDiff.Jacobian(polar_gpu, ExaPF.power_balance, State());\nlinear_solver = LS.DirectSolver();","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Then, solving the powerflow equations on the GPU is straightforward","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"convergence = ExaPF.powerflow(polar_gpu, jx_gpu, physical_state_gpu, pf_algo;\n                              linear_solver=linear_solver)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Note that we get the same convergence pattern as on the CPU.","category":"page"},{"location":"quickstart/#How-to-solve-the-linear-system-with-BICGSTAB?","page":"Quick start","title":"How to solve the linear system with BICGSTAB?","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"By default, the algorithm runs with a direct solver, which might be inefficient for large problems. To overcome this issue, ExaPF implements a wrapper for different iterative algorithms (GMRES, BICGSTAB).","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The performance of iterative solvers is usually improved if we use a preconditioner. ExaPF.jl implements a block-Jacobi preconditioner, tailored for GPU usage. To build an instance with 8 blocks, just write","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"npartitions = 8;\njac_gpu = jx_gpu.J;\nprecond = LS.BlockJacobiPreconditioner(jac_gpu, npartitions, CUDADevice());","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"You can define an iterative solver preconditioned with precond simply as:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"linear_solver = ExaPF.KrylovBICGSTAB(jac_gpu; P=precond);\n","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"(this will use the BICGSTAB algorithm implemented in Krylov.jl).","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"We need to update accordingly the tolerance of the Newton-Raphson algorithm, as it can not be below the tolerance of the iterative solver.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"pf_algo = NewtonRaphson(; verbose=1, tol=1e-7)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Solving the same problem with a different linear solver requires resetting the initial value and the saved solution.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"ExaPF.init_buffer!(polar_gpu, physical_state_gpu)\nconvergence = ExaPF.powerflow(polar_gpu, jx_gpu, physical_state_gpu, pf_algo;\n                              linear_solver=linear_solver)","category":"page"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"CurrentModule = ExaPF.PowerSystem","category":"page"},{"location":"lib/powersystem/#PowerSystem","page":"PowerSystem","title":"PowerSystem","text":"","category":"section"},{"location":"lib/powersystem/#Description","page":"PowerSystem","title":"Description","text":"","category":"section"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"AbstractPowerSystem\nPowerNetwork","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.AbstractPowerSystem","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractPowerSystem","text":"AbstractPowerSystem\n\nFirst layer of the package. Store the topology of a given transmission network, including:\n\nthe power injection at each bus ;\nthe admittance matrix ;\nthe default voltage at each bus.\n\nData are imported either from a matpower file, or a PSSE file.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.PowerNetwork","page":"PowerSystem","title":"ExaPF.PowerSystem.PowerNetwork","text":"PowerNetwork <: AbstractPowerSystem\n\nThis structure contains constant parameters that define the topology and physics of the power network.\n\nThe object PowerNetwork uses its own contiguous indexing for the buses. The indexing is independent from those specified in the Matpower or the PSSE input file. However, a correspondence between the two indexing (Input indexing to PowerNetwork indexing) is stored inside the attribute bus_to_indexes.\n\nNote\n\nThe object PowerNetwork is created in the host memory. Use a AbstractFormulation object to move data to the target device.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#API-Reference","page":"PowerSystem","title":"API Reference","text":"","category":"section"},{"location":"lib/powersystem/#Network-elements","page":"PowerSystem","title":"Network elements","text":"","category":"section"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkElement","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.AbstractNetworkElement","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkElement","text":"AbstractNetworkElement\n\nAbstraction for all physical elements being parts of a AbstractPowerSystem. Elements are divided in\n\ntransmission lines (Lines)\nbuses (Buses)\ngenerators (Generators)\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"List of elements:","category":"page"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"Buses\nLines\nGenerators","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.Buses","page":"PowerSystem","title":"ExaPF.PowerSystem.Buses","text":"Buses <: AbstractNetworkElement\n\nBuses of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.Lines","page":"PowerSystem","title":"ExaPF.PowerSystem.Lines","text":"Lines <: AbstractNetworkElement\n\nLines of a transmission network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.Generators","page":"PowerSystem","title":"ExaPF.PowerSystem.Generators","text":"Generators <: AbstractElement\n\nGenerators in a transmission network\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#Network-attributes","page":"PowerSystem","title":"Network attributes","text":"","category":"section"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkAttribute","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.AbstractNetworkAttribute","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkAttribute","text":"AbstractNetworkAttribute\n\nAttribute of a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"List of attributes:","category":"page"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"NumberOfBuses\nNumberOfLines\nNumberOfGenerators\nNumberOfPVBuses\nNumberOfPQBuses\nNumberOfSlackBuses\nBaseMVA\nBusAdmittanceMatrix","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.NumberOfBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfBuses","text":"NumberOfBuses <: AbstractNetworkAttribute\n\nNumber of buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.NumberOfLines","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfLines","text":"NumberOfLines <: AbstractNetworkAttribute\n\nNumber of lines in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.NumberOfGenerators","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfGenerators","text":"NumberOfGenerators <: AbstractNetworkAttribute\n\nNumber of generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.NumberOfPVBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPVBuses","text":"NumberOfPVBuses <: AbstractNetworkAttribute\n\nNumber of PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.NumberOfPQBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfPQBuses","text":"NumberOfPQBuses <: AbstractNetworkAttribute\n\nNumber of PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.NumberOfSlackBuses","page":"PowerSystem","title":"ExaPF.PowerSystem.NumberOfSlackBuses","text":"NumberOfSlackBuses <: AbstractNetworkAttribute\n\nNumber of slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.BaseMVA","page":"PowerSystem","title":"ExaPF.PowerSystem.BaseMVA","text":"BaseMVA <: AbstractNetworkAttribute\n\nBase MVA of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.BusAdmittanceMatrix","page":"PowerSystem","title":"ExaPF.PowerSystem.BusAdmittanceMatrix","text":"BusAdmittanceMatrix <: AbstractNetworkAttribute\n\nBus admittance matrix associated with the topology of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"Query the indexing of the different elements in a given network:","category":"page"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"PVIndexes\nPQIndexes\nSlackIndexes\nGeneratorIndexes\n","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.PVIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.PVIndexes","text":"PVIndexes <: AbstractIndexing\n\nIndexes of the PV buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.PQIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.PQIndexes","text":"PQIndexes <: AbstractIndexing\n\nIndexes of the PQ buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.SlackIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.SlackIndexes","text":"SlackIndexes <: AbstractIndexing\n\nIndexes of the slack buses in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.GeneratorIndexes","page":"PowerSystem","title":"ExaPF.PowerSystem.GeneratorIndexes","text":"GeneratorIndexes <: AbstractIndexing\n\nIndexes of the generators in a AbstractPowerSystem.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#Network-values","page":"PowerSystem","title":"Network values","text":"","category":"section"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"AbstractNetworkValues","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.AbstractNetworkValues","page":"PowerSystem","title":"ExaPF.PowerSystem.AbstractNetworkValues","text":"AbstractNetworkValues\n\nNumerical values attached to the different attributes of the network.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"List of values:","category":"page"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"VoltageMagnitude\nVoltageAngle\nActivePower\nReactivePower\nActiveLoad\nReactiveLoad\n","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.VoltageMagnitude","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageMagnitude","text":"VoltageMagnitude <: AbstractNetworkValues\n\nMagnitude |v| of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.VoltageAngle","page":"PowerSystem","title":"ExaPF.PowerSystem.VoltageAngle","text":"VoltageAngle <: AbstractNetworkValues\n\nAngle θ of the voltage v = |v| exp(i θ).\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.ActivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ActivePower","text":"ActivePower <: AbstractNetworkValues\n\nActive power P of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.ReactivePower","page":"PowerSystem","title":"ExaPF.PowerSystem.ReactivePower","text":"ReactivePower <: AbstractNetworkValues\n\nReactive power Q of the complex power S = P + iQ.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.ActiveLoad","page":"PowerSystem","title":"ExaPF.PowerSystem.ActiveLoad","text":"ActiveLoad <: AbstractNetworkValues\n\nActive load Pd at buses.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/#ExaPF.PowerSystem.ReactiveLoad","page":"PowerSystem","title":"ExaPF.PowerSystem.ReactiveLoad","text":"ReactiveLoad <: AbstractNetworkValues\n\nReactive load Qd at buses.\n\n\n\n\n\n","category":"type"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"Function to get the range of a given value:","category":"page"},{"location":"lib/powersystem/","page":"PowerSystem","title":"PowerSystem","text":"bounds","category":"page"},{"location":"lib/powersystem/#ExaPF.PowerSystem.bounds","page":"PowerSystem","title":"ExaPF.PowerSystem.bounds","text":"bounds(pf::AbstractPowerSystem, attr::AbstractNetworkAttribute, val::AbstractNetworkValues)\n\nReturn lower and upper bounds corresponding to the admissible values of the AbstractNetworkAttribute attr.\n\nExamples\n\np_min, p_max = bounds(pf, Generator(), ActivePower())\nv_min, v_max = bounds(pf, Buses(), VoltageMagnitude())\n\n\n\n\n\n\n","category":"function"},{"location":"#ExaPF","page":"Home","title":"ExaPF","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExaPF.jl is a package to solve the power flow problem on upcoming exascale architectures by solving a system of nonlinear equations and provide derivative information used for example in a reduced space optimization method. Targeting exascale architectures implies a focus on graphics processing units (GPUs) as these systems lack substantial computational performance through classical CPUs. In addition to providing first-order derivatives ExaPF.jl includes the computation of second-order derivatives using automatic differentiation. All main computational steps, including the linear solver, are executed entirely on the GPU. We leverage the packages CUDA.jl and KernelAbstractions.jl to make ExaPF portable across GPU architectures. Autodiff and Linear solver illustrate the design overview of ExaPF.jl targeted for GPUs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The user API is separated into two layers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"First layer: Physical layer, specify the power network topology in PowerSystem. The first layer provides the physical properties at the electrical engineering level.\nSecond layer: Mathematical layer, using a Polar Formulation to model the equations of the network.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"quickstart.md\",\n]\nDepth=1","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/autodiff.md\",\n    \"man/benchmark.md\",\n    \"man/linearsolver.md\",\n    \"man/powersystem.md\",\n    \"man/formulations.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/autodiff.md\",\n    \"lib/linearsolver.md\",\n    \"lib/powersystem.md\",\n    \"lib/formulations.md\",\n]\nDepth = 1","category":"page"},{"location":"#Artifact","page":"Home","title":"Artifact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"artifact.md\",\n]\nDepth = 1","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This research was supported by the Exascale Computing Project (17-SC-20-SC), a joint project of the U.S. Department of Energy’s Office of Science and National Nuclear Security Administration, responsible for delivering a capable exascale ecosystem, including software, applications, and hardware technology, to support the nation’s exascale computing imperative.","category":"page"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"CurrentModule = ExaPF.LinearSolvers","category":"page"},{"location":"lib/linearsolver/#Linear-solvers","page":"Linear Solver","title":"Linear solvers","text":"","category":"section"},{"location":"lib/linearsolver/#Description","page":"Linear Solver","title":"Description","text":"","category":"section"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"ExaPF allows to solve linear systems with either direct and indirect linear algebra, both on CPU and on GPU. To solve a linear system Ax = b, ExaPF uses the function ldiv!.","category":"page"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"ldiv!","category":"page"},{"location":"lib/linearsolver/#LinearAlgebra.ldiv!","page":"Linear Solver","title":"LinearAlgebra.ldiv!","text":"ldiv!(solver, x, A, y)\nldiv!(solver, x, y)\n\nsolver::AbstractLinearSolver: linear solver to solve the system\nx::AbstractVector: Solution\nA::AbstractMatrix: Input matrix\ny::AbstractVector: RHS\n\nSolve the linear system A x = y using the algorithm specified in solver. If A is not specified, the function will used directly the factorization stored inside solver.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver/#Direct-solvers","page":"Linear Solver","title":"Direct solvers","text":"","category":"section"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"ExaPF wraps UMFPACK (shipped with SuiteSparse.jl) on the CPU, and CUSPARSE on CUDA device.","category":"page"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"DirectSolver","category":"page"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.DirectSolver","page":"Linear Solver","title":"ExaPF.LinearSolvers.DirectSolver","text":"DirectSolver <: AbstractLinearSolver\n\nSolve linear system A x = y with direct linear algebra.\n\nOn the CPU, DirectSolver uses UMFPACK to solve the linear system\nOn CUDA GPU, DirectSolver redirects the resolution to the method CUSOLVER.csrlsvqr\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver/#Iterative-solvers","page":"Linear Solver","title":"Iterative solvers","text":"","category":"section"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"KrylovBICGSTAB\nDQGMRES\nBICGSTAB\nEigenBICGSTAB","category":"page"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.KrylovBICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.KrylovBICGSTAB","text":"KrylovBICGSTAB <: AbstractIterativeLinearSolver\nKrylovBICGSTAB(precond; verbose=0, rtol=1e-10, atol=1e-10)\n\nWrap Krylov.jl's BICGSTAB algorithm to solve iteratively the linear system A x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.DQGMRES","page":"Linear Solver","title":"ExaPF.LinearSolvers.DQGMRES","text":"DQGMRES <: AbstractIterativeLinearSolver\nDQGMRES(precond; verbose=false, memory=4)\n\nWrap Krylov.jl's DQGMRES algorithm to solve iteratively the linear system A x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.BICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.BICGSTAB","text":"BICGSTAB <: AbstractIterativeLinearSolver\nBICGSTAB(precond; maxiter=2_000, tol=1e-8, verbose=false)\n\nCustom BICGSTAB implementation to solve iteratively the linear system A  x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.EigenBICGSTAB","page":"Linear Solver","title":"ExaPF.LinearSolvers.EigenBICGSTAB","text":"EigenBICGSTAB <: AbstractIterativeLinearSolver\nEigenBICGSTAB(precond; maxiter=2_000, tol=1e-8, verbose=false)\n\nJulia's port of Eigen's BICGSTAB to solve iteratively the linear system A x = y.\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"ExaPF.jl is shipped with a custom BICGSTAB implementation. However, we highly recommend to use KrylovBICGSTAB instead, which has proved to be more robust.","category":"page"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"bicgstab\n","category":"page"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.bicgstab","page":"Linear Solver","title":"ExaPF.LinearSolvers.bicgstab","text":"bicgstab(A, b, P, xi;\n         tol=1e-8,\n         maxiter=size(A, 1),\n         verbose=false,\n         maxtol=1e20)\n\nBiCGSTAB implementation according to\n\nVan der Vorst, Henk A. \"Bi-CGSTAB: A fast and smoothly converging variant of Bi-CG for the solution of nonsymmetric linear systems.\" SIAM Journal on scientific and Statistical Computing 13, no. 2 (1992): 631-644.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"Available linear solvers can be queried with","category":"page"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"list_solvers\n","category":"page"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.list_solvers","page":"Linear Solver","title":"ExaPF.LinearSolvers.list_solvers","text":"list_solvers(::KernelAbstractions.Device)\n\nList linear solvers available on current device.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver/#Preconditioning","page":"Linear Solver","title":"Preconditioning","text":"","category":"section"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"To solve linear systems with iterative methods, ExaPF provides an implementation of a block-Jacobi preconditioner, portable on GPU.","category":"page"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"AbstractPreconditioner","category":"page"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.AbstractPreconditioner","page":"Linear Solver","title":"ExaPF.LinearSolvers.AbstractPreconditioner","text":"AbstractPreconditioner\n\nPreconditioners for the iterative solvers mostly focused on GPUs\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver/#Block-Jacobi-preconditioner","page":"Linear Solver","title":"Block-Jacobi preconditioner","text":"","category":"section"},{"location":"lib/linearsolver/","page":"Linear Solver","title":"Linear Solver","text":"BlockJacobiPreconditioner\nupdate\nbuild_adjmatrix\nfillblock_gpu!\nfillP_gpu!","category":"page"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.BlockJacobiPreconditioner","page":"Linear Solver","title":"ExaPF.LinearSolvers.BlockJacobiPreconditioner","text":"BlockJacobiPreconditioner\n\nCreates an object for the block-Jacobi preconditioner\n\nnblocks::Int64: Number of partitions or blocks.\nblocksize::Int64: Size of each block.\nnJs::Int64: Size of the blocks. For the GPUs these all have to be of equal size.\npartitions::Vector{Vector{Int64}}:npart` partitions stored as lists\ncupartitions: partitions transfered to the GPU\nlpartitions::Vector{Int64}`: Length of each partitions.\nculpartitions::Vector{Int64}`: Length of each partitions, on the GPU.\nblocks: Dense blocks of the block-Jacobi\ncublocks: Js transfered to the GPU\nmap: The partitions as a mapping to construct views\ncumap: cumap transferred to the GPU`\npart: Partitioning as output by Metis\ncupart: part transferred to the GPU\nP: The sparse precondition matrix whose values are updated at each iteration\n\n\n\n\n\n","category":"type"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.update","page":"Linear Solver","title":"ExaPF.LinearSolvers.update","text":"function update(J::CuSparseMatrixCSR, p)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSR format for the GPU\n\nThe dense blocks cuJs are filled from the sparse Jacobian J\nTo a batch inversion of the dense blocks using CUBLAS\nExtract the preconditioner matrix p.P from the dense blocks cuJs\n\n\n\n\n\nfunction update(J::SparseMatrixCSC, p)\n\nUpdate the preconditioner p from the sparse Jacobian J in CSC format for the CPU\n\nNote that this implements the same algorithm as for the GPU and becomes very slow on CPU with growing number of blocks.\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.build_adjmatrix","page":"Linear Solver","title":"ExaPF.LinearSolvers.build_adjmatrix","text":"build_adjmatrix\n\nBuild the adjacency matrix of a matrix A corresponding to the undirected graph\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.fillblock_gpu!","page":"Linear Solver","title":"ExaPF.LinearSolvers.fillblock_gpu!","text":"fillblock_gpu\n\nFill the dense blocks of the preconditioner from the sparse CSR matrix arrays\n\n\n\n\n\n","category":"function"},{"location":"lib/linearsolver/#ExaPF.LinearSolvers.fillP_gpu!","page":"Linear Solver","title":"ExaPF.LinearSolvers.fillP_gpu!","text":"fillP_gpu\n\nUpdate the values of the preconditioner matrix from the dense Jacobi blocks\n\n\n\n\n\n","category":"function"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"CurrentModule = ExaPF\nDocTestSetup = quote\n    using ExaPF\n    const AD = ExaPF.AD\nend\nDocTestFilters = [r\"ExaPF\"]","category":"page"},{"location":"man/autodiff/#AutoDiff","page":"AutoDiff","title":"AutoDiff","text":"","category":"section"},{"location":"man/autodiff/#Overview","page":"AutoDiff","title":"Overview","text":"","category":"section"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"Given a set of equations F(x) = 0, the Newton-Raphson algorithm for solving nonlinear equations (see below) requires the Jacobian J = jacobian(x) of F. At each iteration a new step dx is computed by solving a linear system. In our case J is sparse and indefinite.","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"    go = true\n    while(go)\n        dx .= jacobian(x)\\f(x)\n        x  .= x .- dx\n        go = norm(f(x)) < tol ? true : false\n    end","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"There are two modes of differentiation called forward/tangent or reverse/adjoint. The latter is known in machine learning as backpropagation. The forward mode generates Jacobian-vector product code tgt(x,d) = J(x) * d, while the adjoint mode generates code for the transposed Jacobian-vector product adj(x,y) = (J(x)'*y). We recommend the book Evaluating derivatives: principles and techniques of algorithmic differentiation by Griewank and Walther[1] for a more in-depth introduction to automatic differentiation. The computational complexity of both models favors the adjoint mode if the number of outputs of F is much smaller than the number of inputs size(x) >> size(F), like for example the loss functions in machine learning. However, in our case F is a multivariate vector function from mathbbR^n to mathbbR^n, where n is the number of buses.","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"(Image: Jacobian coloring \\label{fig:coloring})","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"To avoid a complexity of mathcalO(n) cdot cost(F) by letting the tangent mode run over all Cartesian basis vectors of mathbbR^n, we apply the technique of Jacobian coloring to compress the sparse Jacobian J. Running the tangent mode, it allows to compute columns of the Jacobian concurrently, by combining independent columns in one Jacobian-vector evaluation (see in figure above). For sparsity detection we rely on the greedy algorithm implemented by SparseDiffTools.jl.","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"Given the sparsity pattern, the forward model is applied through the package ForwardDiff.jl. Given the number of Jacobian colors c we can build our dual type t1s with c directions:","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"t1s{N} = ForwardDiff.Dual{Nothing,Float64, N} where N}","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"Note that a second-order type t2s can be created naturally by applying the same logic to t1s:","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"t2s{M,N} =  ForwardDiff.Dual{Nothing,t1s{N}, M} where M, N}","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"Finally, this dual type can be ported to both vector types Vector and CuVector:","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"VT = Vector{Float64}\nVT = Vector{t1s{N}}}\nVT = CuVector{t1s{N}}}","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"Setting VT to either of the three types allows us to instantiate code that has been written using the broadcast operator .","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"x .= a .* b","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"or accessed in kernels written for KernelAbstractions.jl like for example the power flow equations (here in polar form):","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"@kernel function residual_kernel!(F, v_m, v_a,\n                                  ybus_re_nzval, ybus_re_colptr, ybus_re_rowval,\n                                  ybus_im_nzval, ybus_im_colptr, ybus_im_rowval,\n                                  pinj, qinj, pv, pq, nbus)\n\n    npv = size(pv, 1)\n    npq = size(pq, 1)\n\n    i = @index(Global, Linear)\n    # REAL PV: 1:npv\n    # REAL PQ: (npv+1:npv+npq)\n    # IMAG PQ: (npv+npq+1:npv+2npq)\n    fr = (i <= npv) ? pv[i] : pq[i - npv]\n    F[i] -= pinj[fr]\n    if i > npv\n        F[i + npq] -= qinj[fr]\n    end\n    @inbounds for c in ybus_re_colptr[fr]:ybus_re_colptr[fr+1]-1\n        to = ybus_re_rowval[c]\n        aij = v_a[fr] - v_a[to]\n        coef_cos = v_m[fr]*v_m[to]*ybus_re_nzval[c]\n        coef_sin = v_m[fr]*v_m[to]*ybus_im_nzval[c]\n        cos_val = cos(aij)\n        sin_val = sin(aij)\n        F[i] += coef_cos * cos_val + coef_sin * sin_val\n        if i > npv\n            F[npq + i] += coef_cos * sin_val - coef_sin * cos_val\n        end\n    end\nend","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"These two abstractions are a powerful tool that allow us to implement the forward mode in vectorized form where the number of directions or tangent components of a tangent variable are the number of Jacobian colors. We illustrate this in the figure below with a point-wise vector product x .* y","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"(Image: SIMD AD for point-wise vector product \\label{fig:simd})","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"This natural way of computing the compressed Jacobian yields a very high performing code that is portable to any vector architecture, given that a similar package like CUDA.jl exists. We note that similar packages for the Intel Compute Engine and AMD ROCm are in development called oneAPI.jl and AMDGPU.jl, respectively. We expect our package to be portable to AMD and Intel GPUs in the future.","category":"page"},{"location":"man/autodiff/","page":"AutoDiff","title":"AutoDiff","text":"[1]: Griewank, Andreas, and Andrea Walther. Evaluating derivatives: principles and techniques of algorithmic differentiation. Society for Industrial and Applied Mathematics, 2008.","category":"page"}]
}
