<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick start · ExaPF.jl</title><meta name="title" content="Quick start · ExaPF.jl"/><meta property="og:title" content="Quick start · ExaPF.jl"/><meta property="twitter:title" content="Quick start · ExaPF.jl"/><meta name="description" content="Documentation for ExaPF.jl."/><meta property="og:description" content="Documentation for ExaPF.jl."/><meta property="twitter:description" content="Documentation for ExaPF.jl."/><meta property="og:url" content="https://exanauts.github.io/ExaPF.jl/stable/quickstart/"/><meta property="twitter:url" content="https://exanauts.github.io/ExaPF.jl/stable/quickstart/"/><link rel="canonical" href="https://exanauts.github.io/ExaPF.jl/stable/quickstart/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExaPF.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Quick start</a><ul class="internal"><li><a class="tocitem" href="#Short-version"><span>Short version</span></a></li><li><a class="tocitem" href="#Detailed-version"><span>Detailed version</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/direct_solver/">Power flow: direct solver</a></li><li><a class="tocitem" href="../tutorials/batch_evaluation/">Power flow: batch evaluation</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/powersystem/">PowerSystem</a></li><li><a class="tocitem" href="../man/formulations/">Polar formulation</a></li><li><a class="tocitem" href="../man/autodiff/">AutoDiff</a></li><li><a class="tocitem" href="../man/linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../man/benchmark/">Benchmark</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../lib/powersystem/">PowerSystem</a></li><li><a class="tocitem" href="../lib/formulations/">Polar formulation</a></li><li><a class="tocitem" href="../lib/autodiff/">AutoDiff</a></li><li><a class="tocitem" href="../lib/linearsolver/">Linear Solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick start</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/exanauts/ExaPF.jl/blob/main/docs/src/quickstart.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h1><p>This page introduces the first steps to set up <code>ExaPF.jl</code>. We show how to load a power network instance and how to solve the power flow equations both on the CPU and on the GPU. The full script is implemented in <a href="https://github.com/exanauts/ExaPF.jl/tree/main/test/quickstart.jl">test/quickstart.jl</a>.</p><p>We start by importing CUDA and KernelAbstractions:</p><pre><code class="language- hljs">using CUDA
using KernelAbstractions</code></pre><p>Then, we load ExaPF and its submodules with</p><pre><code class="language- hljs">using ExaPF
import ExaPF: AutoDiff
const PS = ExaPF.PowerSystem
const LS = ExaPF.LinearSolvers</code></pre><h2 id="Short-version"><a class="docs-heading-anchor" href="#Short-version">Short version</a><a id="Short-version-1"></a><a class="docs-heading-anchor-permalink" href="#Short-version" title="Permalink"></a></h2><p>ExaPF loads instances from the <a href="https://github.com/power-grid-lib/pglib-opf"><code>pglib-opf</code></a> benchmark. ExaPF contains an artifact defined in <code>Artifacts.toml</code> that is built from the <a href="https://github.com/exanauts/ExaData"><code>ExaData</code></a> repository containing Exascale Computing Project relevant test cases. You may set a data file using</p><pre><code class="language-julia hljs">datafile = joinpath(artifact&quot;ExaData&quot;, &quot;ExaData&quot;, &quot;case1354.m&quot;)</code></pre><h3 id="Single-scenario-power-flow"><a class="docs-heading-anchor" href="#Single-scenario-power-flow">Single scenario power flow</a><a id="Single-scenario-power-flow-1"></a><a class="docs-heading-anchor-permalink" href="#Single-scenario-power-flow" title="Permalink"></a></h3><p>The powerflow equations can be solved in a single line of code using the <code>run_pf</code> interface:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result = run_pf(datafile, CPU(), :polar; verbose=1)</code><code class="nohighlight hljs ansi" style="display:block;">#it 0: 1.15103e+02
#it 1: 1.50328e+01
#it 2: 5.88242e-01
#it 3: 4.88493e-03
#it 4: 1.39924e-06
#it 5: 1.57368e-11
PowerFlowProblem
  Formulation: Polar formulation (instantiated on backend CPU(false))
Network characteristics:
    #buses:      1354  (#slack: 1  #PV: 259  #PQ: 1094)
    #generators: 260
    #lines:      1991
giving a mathematical formulation with:
    #controls:   519
    #states  :   2447
  Non-linear solver: NewtonRaphson(20, 1.0e-8, 1)
  Convergence status: Power flow has converged: true
  * #iterations: 5
  * Time Jacobian (s) ........: 0.0025
  * Time linear solver (s) ...: 0.0012
     * update (s) ............: 0.0010
     * ldiv (s) ..............: 0.0002
  * Time total (s) ...........: 0.3125

  Backend: CPU(false)</code></pre><p>You can extract the solution from the result:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; solution = get_solution(result)</code><code class="nohighlight hljs ansi" style="display:block;">2447-element Vector{Float64}:
  0.11145547613273997
  0.055435156341501854
 -0.06025458020329497
 -0.010070069933294014
  0.05028039997845452
 -0.14718949906179726
 -0.062297668026916254
 -0.7005584676325493
 -0.9396109768988795
 -0.1481713854861242
  ⋮
  1.009647610776089
  1.010094675993438
  1.0280515600881874
  0.9972319737422162
  0.9904486795504038
  0.9947996968345935
  0.9995418731867062
  0.9971095378668321
  1.0138255275974881</code></pre><p>Implicitly, ExaPF has just proceeded to the following operations:</p><ul><li>load the power network data from the file</li><li>instantiate automatically a starting point <span>$x_0$</span></li><li>instantiate the Jacobian of the powerflow equations using AutoDiff</li><li>solve the powerflow equations iteratively, using a Newton-Raphson algorithm</li></ul><h3 id="Batched-power-flow-for-multiple-scenarios"><a class="docs-heading-anchor" href="#Batched-power-flow-for-multiple-scenarios">Batched power flow for multiple scenarios</a><a id="Batched-power-flow-for-multiple-scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Batched-power-flow-for-multiple-scenarios" title="Permalink"></a></h3><p>ExaPF also supports solving multiple power flow scenarios simultaneously in a batched fashion. This is particularly useful for uncertainty quantification, contingency analysis, or any application requiring solutions for many different load scenarios.</p><p>First, we need to create load matrices for multiple scenarios:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nscen = 10</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polar = ExaPF.load_polar(datafile)</code><code class="nohighlight hljs ansi" style="display:block;">Polar formulation (instantiated on backend CPU(false))
Network characteristics:
    #buses:      1354  (#slack: 1  #PV: 259  #PQ: 1094)
    #generators: 260
    #lines:      1991
giving a mathematical formulation with:
    #controls:   519
    #states  :   2447</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nbus = PS.get(polar, PS.NumberOfBuses())</code><code class="nohighlight hljs ansi" style="display:block;">1354</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stack = ExaPF.NetworkStack(polar)</code><code class="nohighlight hljs ansi" style="display:block;">2968-elements NetworkStack{Vector{Float64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pload = stack.params[1:nbus]</code><code class="nohighlight hljs ansi" style="display:block;">1354-element Vector{Float64}:
  1.51
  1.7141
  1.34
  1.6119999999999999
  0.0
  1.673
  1.5290000000000001
 -0.0
  0.4865
  0.0
  ⋮
  0.6697
  0.6257
 -0.0
  6.2736
 -0.0
 -0.0
 -0.051500000000000004
  2.4208000000000003
  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; qload = stack.params[nbus+1:2*nbus]</code><code class="nohighlight hljs ansi" style="display:block;">1354-element Vector{Float64}:
  0.488
  0.23399999999999999
  0.247
  0.39299999999999996
 -0.0
  0.5479999999999999
  0.494
  0.0
  0.161
  0.0
  ⋮
  0.18600000000000003
 -0.61
 -0.0
 -0.7313
 -0.0
  0.0
 -0.0204
  0.5998
 -0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ploads = repeat(pload, 1, nscen)  # Matrix of size (nbus, nscen)</code><code class="nohighlight hljs ansi" style="display:block;">1354×10 Matrix{Float64}:
  1.51     1.51     1.51     1.51    …   1.51     1.51     1.51     1.51
  1.7141   1.7141   1.7141   1.7141      1.7141   1.7141   1.7141   1.7141
  1.34     1.34     1.34     1.34        1.34     1.34     1.34     1.34
  1.612    1.612    1.612    1.612       1.612    1.612    1.612    1.612
  0.0      0.0      0.0      0.0         0.0      0.0      0.0      0.0
  1.673    1.673    1.673    1.673   …   1.673    1.673    1.673    1.673
  1.529    1.529    1.529    1.529       1.529    1.529    1.529    1.529
 -0.0     -0.0     -0.0     -0.0        -0.0     -0.0     -0.0     -0.0
  0.4865   0.4865   0.4865   0.4865      0.4865   0.4865   0.4865   0.4865
  0.0      0.0      0.0      0.0         0.0      0.0      0.0      0.0
  ⋮                                  ⋱
  0.6697   0.6697   0.6697   0.6697  …   0.6697   0.6697   0.6697   0.6697
  0.6257   0.6257   0.6257   0.6257      0.6257   0.6257   0.6257   0.6257
 -0.0     -0.0     -0.0     -0.0        -0.0     -0.0     -0.0     -0.0
  6.2736   6.2736   6.2736   6.2736      6.2736   6.2736   6.2736   6.2736
 -0.0     -0.0     -0.0     -0.0        -0.0     -0.0     -0.0     -0.0
 -0.0     -0.0     -0.0     -0.0     …  -0.0     -0.0     -0.0     -0.0
 -0.0515  -0.0515  -0.0515  -0.0515     -0.0515  -0.0515  -0.0515  -0.0515
  2.4208   2.4208   2.4208   2.4208      2.4208   2.4208   2.4208   2.4208
  0.0      0.0      0.0      0.0         0.0      0.0      0.0      0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; qloads = repeat(qload, 1, nscen)  # Matrix of size (nbus, nscen)</code><code class="nohighlight hljs ansi" style="display:block;">1354×10 Matrix{Float64}:
  0.488    0.488    0.488    0.488   …   0.488    0.488    0.488    0.488
  0.234    0.234    0.234    0.234       0.234    0.234    0.234    0.234
  0.247    0.247    0.247    0.247       0.247    0.247    0.247    0.247
  0.393    0.393    0.393    0.393       0.393    0.393    0.393    0.393
 -0.0     -0.0     -0.0     -0.0        -0.0     -0.0     -0.0     -0.0
  0.548    0.548    0.548    0.548   …   0.548    0.548    0.548    0.548
  0.494    0.494    0.494    0.494       0.494    0.494    0.494    0.494
  0.0      0.0      0.0      0.0         0.0      0.0      0.0      0.0
  0.161    0.161    0.161    0.161       0.161    0.161    0.161    0.161
  0.0      0.0      0.0      0.0         0.0      0.0      0.0      0.0
  ⋮                                  ⋱
  0.186    0.186    0.186    0.186   …   0.186    0.186    0.186    0.186
 -0.61    -0.61    -0.61    -0.61       -0.61    -0.61    -0.61    -0.61
 -0.0     -0.0     -0.0     -0.0        -0.0     -0.0     -0.0     -0.0
 -0.7313  -0.7313  -0.7313  -0.7313     -0.7313  -0.7313  -0.7313  -0.7313
 -0.0     -0.0     -0.0     -0.0        -0.0     -0.0     -0.0     -0.0
  0.0      0.0      0.0      0.0     …   0.0      0.0      0.0      0.0
 -0.0204  -0.0204  -0.0204  -0.0204     -0.0204  -0.0204  -0.0204  -0.0204
  0.5998   0.5998   0.5998   0.5998      0.5998   0.5998   0.5998   0.5998
 -0.0     -0.0     -0.0     -0.0        -0.0     -0.0     -0.0     -0.0</code></pre><p>Then solve all scenarios at once:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result_batch = run_pf(datafile, CPU(), :block_polar, nscen, ploads, qloads; verbose=1)</code><code class="nohighlight hljs ansi" style="display:block;">#it 0: 3.63987e+02
#it 1: 4.75380e+01
#it 2: 1.86019e+00
#it 3: 1.54475e-02
#it 4: 4.42479e-06
#it 5: 4.97643e-11
PowerFlowProblem
  Formulation: Polar formulation (instantiated on backend CPU(false))
Network characteristics:
    #buses:      1354  (#slack: 1  #PV: 259  #PQ: 1094)
    #generators: 260
    #lines:      1991
giving a mathematical formulation with:
    #controls:   519
    #states  :   2447
  Non-linear solver: NewtonRaphson(20, 1.0e-8, 1)
  Convergence status: Power flow has converged: true
  * #iterations: 5
  * Time Jacobian (s) ........: 0.0245
  * Time linear solver (s) ...: 0.0103
     * update (s) ............: 0.0088
     * ldiv (s) ..............: 0.0014
  * Time total (s) ...........: 0.0365

  Backend: CPU(false)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; solution_batch = get_solution(result_batch)</code><code class="nohighlight hljs ansi" style="display:block;">24470-element Vector{Float64}:
  0.11145547613273997
  0.055435156341501854
 -0.06025458020329497
 -0.010070069933294014
  0.05028039997845452
 -0.14718949906179726
 -0.062297668026916254
 -0.7005584676325493
 -0.9396109768988795
 -0.1481713854861242
  ⋮
  1.009647610776089
  1.010094675993438
  1.0280515600881874
  0.9972319737422162
  0.9904486795504038
  0.9947996968345935
  0.9995418731867062
  0.9971095378668321
  1.0138255275974881</code></pre><p>The batched solution is a vector containing all scenarios stacked together, where each scenario&#39;s solution has length <code>nbus</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; size(solution_batch)</code><code class="nohighlight hljs ansi" style="display:block;">(24470,)</code></pre><p>This compact syntax allows to solve quickly any powerflow equations in a few lines of code. However, in most cases, the user may want more coarse-grained control on the different objects manipulated.</p><h2 id="Detailed-version"><a class="docs-heading-anchor" href="#Detailed-version">Detailed version</a><a id="Detailed-version-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-version" title="Permalink"></a></h2><p>In what follows, we detail step by step the detailed procedure to solve the powerflow equations.</p><h3 id="How-to-load-a-MATPOWER-instance-as-a-PowerNetwork-object?"><a class="docs-heading-anchor" href="#How-to-load-a-MATPOWER-instance-as-a-PowerNetwork-object?">How to load a MATPOWER instance as a PowerNetwork object?</a><a id="How-to-load-a-MATPOWER-instance-as-a-PowerNetwork-object?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-load-a-MATPOWER-instance-as-a-PowerNetwork-object?" title="Permalink"></a></h3><p>We start by importing a MATPOWER instance to a <a href="../lib/powersystem/#ExaPF.PowerSystem.PowerNetwork"><code>ExaPF.PowerSystem.PowerNetwork</code></a> object:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pf = PS.PowerNetwork(datafile)</code><code class="nohighlight hljs ansi" style="display:block;">PowerNetwork object with:
    Buses: 1354 (Slack: 1. PV: 259. PQ: 1094)
    Generators: 260.</code></pre><p>The different fields of the object <code>pf</code> specify the characteristics of the network. For instance, we can retrieve the number of buses or get the indexing of the PV buses with</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nbus = PS.get(pf, PS.NumberOfBuses())</code><code class="nohighlight hljs ansi" style="display:block;">1354</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pv_indexes = pf.pv;</code></pre><p>However, a <a href="../lib/powersystem/#ExaPF.PowerSystem.PowerNetwork"><code>ExaPF.PowerSystem.PowerNetwork</code></a> object stores only the <strong>physical</strong> attributes of the network. To choose a given mathematical formulation, we need to pass the object <code>pf</code> to an <a href="../lib/formulations/#ExaPF.AbstractFormulation"><code>ExaPF.AbstractFormulation</code></a> layer. Currently, only the polar formulation is provided with the <a href="../lib/formulations/#ExaPF.PolarForm"><code>ExaPF.PolarForm</code></a> structure. In the future, other formulations (e.g. <code>RectangularForm</code>) may be implemented as well.</p><h3 id="How-to-solve-the-powerflow-equations?"><a class="docs-heading-anchor" href="#How-to-solve-the-powerflow-equations?">How to solve the powerflow equations?</a><a id="How-to-solve-the-powerflow-equations?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-solve-the-powerflow-equations?" title="Permalink"></a></h3><p>To solve the powerflow equations, we need to choose a given mathematical formulation for the equations of the network. To each formulation corresponds a given state <span>$x$</span> and control <span>$u$</span>. Using polar representation of the voltage vector, such as <span>$\bm{v} = |v|e^{j \theta}$</span>, each bus <span>$i=1, \cdots, N_B$</span> must satisfy the power balance equations:</p><p class="math-container">\[\begin{aligned}
    p_i &amp;= v_i \sum_{j}^{n} v_j (g_{ij}\cos{(\theta_i - \theta_j)} + b_{ij}\sin{(\theta_i - \theta_j})) \,, \\
    q_i &amp;= v_i \sum_{j}^{n} v_j (g_{ij}\sin{(\theta_i - \theta_j)} - b_{ij}\cos{(\theta_i - \theta_j})) \,.
\end{aligned}\]</p><p>The powerflow equations rewrite in the abstract mathematical formalism:</p><p class="math-container">\[g(x, u) = 0.\]</p><p>For a given control <span>$u$</span>, solving the powerflow equations resumes to find a state <span>$x(u)$</span> such that <span>$g(x(u), u) = 0$</span>.</p><p>To this goal, <code>ExaPF.jl</code> implements a Newton-Raphson algorithm that allows to solve the powerflow equations in a few lines of code. We first instantiate a <code>PolarForm</code> object to adopt a polar formulation as a model:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; polar = ExaPF.PolarForm(pf, CPU())</code><code class="nohighlight hljs ansi" style="display:block;">Polar formulation (instantiated on backend CPU(false))
Network characteristics:
    #buses:      1354  (#slack: 1  #PV: 259  #PQ: 1094)
    #generators: 260
    #lines:      1991
giving a mathematical formulation with:
    #controls:   519
    #states  :   2447</code></pre><p>Note that the constructor <a href="../lib/formulations/#ExaPF.PolarForm"><code>ExaPF.PolarForm</code></a> takes as input a <a href="../lib/powersystem/#ExaPF.PowerSystem.PowerNetwork"><code>ExaPF.PowerSystem.PowerNetwork</code></a> object and a <code>KernelAbstractions.jl</code> backend (here set to <code>CPU()</code> by default). We will explain in the next section how to load a <a href="../lib/formulations/#ExaPF.PolarForm"><code>ExaPF.PolarForm</code></a> object on the GPU with the help of a <code>CUDABackend()</code>.</p><p>The Newton-Raphson solves the equation <span>$g(x, u) = 0$</span> in an iterative fashion. The algorithm solves at each step the linear equation:</p><p class="math-container">\[    x_{k+1} = - (\nabla_x g_k)^{-1} g(x_k, u).\]</p><p>Hence, the algorithm requires the following elements:</p><ul><li>an initial variable <span>$x_0$</span></li><li>a function to solve efficiently the linear system <span>$(\nabla_x g_k) x_{k+1} = g(x_k, u)$</span></li><li>a function to evaluate the Jacobian <span>$\nabla_x g_k$</span></li></ul><p>The variable <span>$x$</span> is instantiated as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; stack = ExaPF.NetworkStack(polar)</code><code class="nohighlight hljs ansi" style="display:block;">2968-elements NetworkStack{Vector{Float64}}</code></pre><p>The function <span>$g$</span> is implemented using ExaPF&#39;s custom modeler:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; basis = ExaPF.Basis(polar)</code><code class="nohighlight hljs ansi" style="display:block;">Basis (AbstractExpression)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; powerflow = ExaPF.PowerFlowBalance(polar) ∘ basis</code><code class="nohighlight hljs ansi" style="display:block;">ExaPF.ComposedExpressions{ExaPF.Basis{Vector{Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, ExaPF.PowerFlowBalance{Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}}(Basis (AbstractExpression), PowerFlowBalance (AbstractExpression))</code></pre><p>The Jacobian <span>$\nabla_x g$</span> is evaluated automatically using forward-mode AutoDiff:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mapx = ExaPF.mapping(polar, State());</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; jx = ExaPF.Jacobian(polar, powerflow, mapx)</code><code class="nohighlight hljs ansi" style="display:block;">A AutoDiff Jacobian for ExaPF.ComposedExpressions{ExaPF.Basis{Vector{Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, ExaPF.PowerFlowBalance{Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}}(Basis (AbstractExpression), PowerFlowBalance (AbstractExpression))
Number of Jacobian colors: 25</code></pre><p>The (direct) linear solver can be instantiated directly as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; linear_solver = LS.DirectSolver(jx.J);</code></pre><p>Let&#39;s explain further these three objects.</p><ul><li><code>stack</code> is a <code>AbstractStack</code> storing all the variables attached to the formulation <code>polar::PolarForm</code>.</li><li><code>jx</code> is a <code>Jacobian</code> structure which allows the solver to compute efficiently the Jacobian of the powerflow equations <span>$\nabla_x g$</span> using AutoDiff.</li><li><code>linear_solver</code> specifies the linear algorithm uses to solve the linear system <span>$(\nabla_x g_k) x_{k+1} = g(x_k, u)$</span>. By default, we use direct sparse linear solvers.</li></ul><p>In the AutoDiff Jacobian <code>jx</code>, the evaluation of the Jacobian <span>$J$</span> is stored in <code>jx.J</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; jac = jx.J</code><code class="nohighlight hljs ansi" style="display:block;">2447×2447 SparseArrays.SparseMatrixCSC{Float64, Int64} with 15803 stored entries:
⎡⢿⣷⣲⣷⣯⣷⣣⢯⣮⣌⢫⡿⣿⣲⢡⣾⡾⣶⣰⣷⡧⣾⣵⣿⢺⣵⣧⣙⣿⢿⣟⡮⢴⣗⣷⣶⣾⣿⡱⡧⎤
⎢⢼⣾⣿⣿⣿⡺⣶⣿⣟⢷⣲⣿⣷⣿⣳⡟⢹⡿⣿⢿⢓⣻⡗⣾⢼⡿⡿⣆⣾⣾⣯⣗⢿⠃⡻⣿⡿⣟⢚⣧⎥
⎢⢯⣿⣻⡻⢟⣵⢿⣟⣇⣾⣵⣿⡿⡷⣿⣿⢿⣿⢿⢟⣿⡽⢿⣾⢟⣾⣷⣫⣾⣿⣿⡾⣯⣾⣟⡿⡷⣿⣿⠿⎥
⎢⡭⣞⣼⣿⣿⢷⡿⣯⣧⣿⢿⣾⣷⣷⡫⣧⣻⣻⣵⢾⡹⣻⡿⣿⢿⣿⣹⣾⣿⣿⣶⡟⣻⣌⣿⣮⣷⡏⣿⡇⎥
⎢⡊⢿⢿⣝⣩⣽⣭⣿⣿⢟⣻⣿⡷⢿⢽⣯⣿⢾⣼⡻⢽⣼⢯⡻⣽⢿⡿⣟⣿⣿⠿⣿⣿⣽⡷⣿⣽⡯⣧⣿⎥
⎢⣯⡶⣼⣾⣵⣿⣻⣷⣿⣾⡛⣬⣛⣿⢻⣽⠽⣯⣿⣳⣙⣿⣾⣝⣿⣴⡿⣿⢳⣽⣻⡯⣯⡿⢧⣻⣾⣏⣻⢗⎥
⎢⢻⣻⣽⣿⢿⡯⢽⣿⣽⣏⣿⣼⡿⣯⣞⣷⡿⣹⡽⣗⣾⣟⢵⡭⣿⡯⣷⣹⣧⣻⢿⣷⣳⣳⠯⣿⣯⣷⣾⡝⎥
⎢⣡⣶⣽⠾⣿⣿⠯⣮⡷⣷⣟⣶⢾⣽⣻⣾⣷⣷⢿⣿⣾⣳⣿⣿⢵⣾⢿⣾⣻⣦⢯⣞⣿⣿⣿⢿⣟⣿⣟⣜⎥
⎢⢺⣯⣷⡶⣿⣷⣿⣺⣻⣟⡷⣧⣟⣫⢽⣿⡻⣮⣿⣳⢻⣿⣷⢿⢟⣞⣯⣷⣻⣾⣓⣩⣿⣟⢿⣾⣟⡮⣺⣿⎥
⎢⢴⣾⣿⣟⣿⢗⣱⣟⣶⡻⢿⣻⢷⢯⣿⣷⢿⣻⢿⢗⣚⣞⣾⣒⣿⣷⣖⡷⣿⡿⡼⣿⣿⣾⣿⣯⣿⣖⢺⡹⎥
⎢⣩⣯⣽⣰⣟⡿⣷⣪⣓⣷⣷⣼⣾⢿⢾⣻⣿⣶⣺⢼⡿⣯⣿⢿⣗⣝⣹⣿⢷⣷⡾⡷⢟⢿⣷⣲⡯⣞⣿⣿⎥
⎢⣵⣿⣹⣭⣻⣷⣿⣯⣯⡳⣞⢿⡕⡷⣿⣿⣽⣟⢺⢻⣿⣟⣿⣿⢯⣟⣟⢶⣾⣻⣻⣿⣷⢯⣿⣟⡟⣿⡽⡻⎥
⎢⢞⣶⣶⡷⣻⣵⣿⣷⣷⣟⢛⣿⡿⡿⣱⣷⣻⢵⢿⣿⣝⢽⣯⢷⣿⣿⣽⣟⣻⣿⢿⠏⣹⣦⡿⢶⣿⣏⡿⢇⎥
⎢⣍⢻⠻⢯⡽⣻⣳⣾⣿⢯⣿⣯⣝⣻⣻⣷⢯⣿⢼⡽⣷⣾⢻⣝⣷⢿⣟⣽⡻⣭⣛⣽⢿⡿⡿⣳⣾⣗⣷⡻⎥
⎢⣿⣟⣺⣿⣾⣿⣿⣿⣿⣿⣝⣶⣭⣻⠻⣾⣻⣾⣿⡿⢽⣷⣾⣻⣿⣾⡟⣮⣻⣾⣝⡷⢷⡟⣧⣾⣿⡯⢿⣲⎥
⎢⡻⡽⢯⢿⣻⡿⣼⠿⣿⣧⡿⡾⢿⣷⣫⢷⡝⣸⣶⣯⢾⡯⣿⣾⡿⠗⣟⣼⢷⡽⣿⣿⣹⣿⣗⡿⣦⣷⣿⣎⎥
⎢⢴⢷⠿⠓⣫⣿⡛⢾⣟⣿⣯⡿⢽⣺⣿⣿⣿⢿⣻⣿⣿⣕⡽⣟⠳⣾⣿⡷⣽⠷⣷⣾⣿⣿⣿⢿⣿⣿⣯⣶⎥
⎢⢹⣿⣿⣮⣿⡽⡻⣿⣽⣯⣭⣳⣯⣧⣿⣟⣻⣷⡿⣿⢹⣻⣿⢿⢻⣏⢿⣫⣩⣿⣽⡽⣿⣟⣵⣿⣿⡷⣽⣷⎥
⎢⣾⣿⣿⢯⣽⣯⡽⠿⡷⡿⡾⢿⢯⣿⣿⣽⡻⡽⢻⢿⣫⢯⣿⣭⡿⢿⢾⢿⡿⡿⢬⣿⣿⣿⢿⡿⣵⣿⣹⣝⎥
⎣⠵⡮⠾⣴⣿⡟⠿⠿⣭⣿⢿⢞⣞⠿⣛⢽⣾⣾⣞⡲⣿⣿⣷⡫⠿⢏⣽⡻⢻⣳⡻⢿⢫⣿⢷⣿⣗⢾⣿⣿⎦</code></pre><p>This matrix is at the basis of the powerflow algorithm. At each iteration, the AutoDiff backend updates the nonzero values in the sparse Jacobian <code>jx</code> and solve the associated linear system to compute the next descent direction.</p><p>The procedure is implemented in the <code>nlsolve!</code> function, which uses a Newton-Raphson algorithm to solve the powerflow equations. The Newton-Raphson algorithm is specified as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pf_algo = NewtonRaphson(; verbose=1, tol=1e-10)</code><code class="nohighlight hljs ansi" style="display:block;">NewtonRaphson(20, 1.0e-10, 1)</code></pre><p>Then, we can solve the powerflow equations simply with</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; convergence = ExaPF.nlsolve!(pf_algo, jx, stack; linear_solver=linear_solver)</code><code class="nohighlight hljs ansi" style="display:block;">#it 0: 1.15103e+02
#it 1: 1.50328e+01
#it 2: 5.88242e-01
#it 3: 4.88493e-03
#it 4: 1.39924e-06
#it 5: 1.57368e-11
Power flow has converged: true
  * #iterations: 5
  * Time Jacobian (s) ........: 0.0023
  * Time linear solver (s) ...: 0.0012
     * update (s) ............: 0.0010
     * ldiv (s) ..............: 0.0002
  * Time total (s) ...........: 0.0037</code></pre><p>Here, the algorithm solves the powerflow equations in 5 iterations. The algorithm modifies the values of <code>stack</code> inplace, to avoid any unnecessary memory allocations.</p><h3 id="How-to-deport-the-computation-on-the-GPU?"><a class="docs-heading-anchor" href="#How-to-deport-the-computation-on-the-GPU?">How to deport the computation on the GPU?</a><a id="How-to-deport-the-computation-on-the-GPU?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-deport-the-computation-on-the-GPU?" title="Permalink"></a></h3><p>Now, how can we deport the resolution on the GPU? The procedure looks exactly the same. It suffices to initiate a new <a href="../lib/formulations/#ExaPF.PolarForm"><code>ExaPF.PolarForm</code></a> object, but on the GPU:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; polar_gpu = ExaPF.PolarForm(pf, CUDABackend())</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching PolarForm(::ExaPF.PowerSystem.PowerNetwork, ::CUDABackend)

Closest candidates are:
  PolarForm(::ExaPF.PowerSystem.PowerNetwork, <span class="sgr91">::CPU</span>)
<span class="sgr90">   @</span> <span class="sgr35">ExaPF</span> <span class="sgr90">/storage/mschanen/github-actions/actions_runner_exanauts/_work/ExaPF.jl/ExaPF.jl/src/Polar/<span class="sgr4">polar.jl:42</span></span>
  PolarForm(::ExaPF.PowerSystem.PowerNetwork, <span class="sgr91">::CPU</span>, <span class="sgr91">::Int64</span>)
<span class="sgr90">   @</span> <span class="sgr35">ExaPF</span> <span class="sgr90">/storage/mschanen/github-actions/actions_runner_exanauts/_work/ExaPF.jl/ExaPF.jl/src/Polar/<span class="sgr4">polar.jl:42</span></span>
  PolarForm(<span class="sgr91">::String</span>, ::Any; ncustoms)
<span class="sgr90">   @</span> <span class="sgr35">ExaPF</span> <span class="sgr90">/storage/mschanen/github-actions/actions_runner_exanauts/_work/ExaPF.jl/ExaPF.jl/src/Polar/<span class="sgr4">polar.jl:46</span></span>
  ...</code></pre><p><code>polar_gpu</code> will load all the structures it needs on the GPU, to avoid unnecessary movements between the host and the backend. We can load the other structures directly on the GPU with:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; stack_gpu = ExaPF.NetworkStack(polar_gpu)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `polar_gpu` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; basis_gpu = ExaPF.Basis(polar_gpu)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `polar_gpu` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pflow_gpu = ExaPF.PowerFlowBalance(polar_gpu) ∘ basis_gpu</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `polar_gpu` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; jx_gpu = ExaPF.Jacobian(polar_gpu, pflow_gpu, mapx)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `polar_gpu` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; linear_solver = LS.DirectSolver(jx_gpu.J)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `jx_gpu` not defined</code></pre><p>Then, solving the powerflow equations on the GPU directly translates as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; convergence = ExaPF.nlsolve!(pf_algo, jx_gpu, stack_gpu; linear_solver=linear_solver)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `jx_gpu` not defined</code></pre><p>Note that we get exactly the same iterations as when we solve the power flow equations on the CPU.</p><h3 id="How-to-solve-the-linear-system-with-BICGSTAB?"><a class="docs-heading-anchor" href="#How-to-solve-the-linear-system-with-BICGSTAB?">How to solve the linear system with BICGSTAB?</a><a id="How-to-solve-the-linear-system-with-BICGSTAB?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-solve-the-linear-system-with-BICGSTAB?" title="Permalink"></a></h3><p>By default, the algorithm runs with a direct solver, which might be inefficient for large problems. To overcome this issue, ExaPF implements a wrapper for different iterative algorithms (GMRES, BICGSTAB).</p><p>The performance of iterative solvers is usually improved if we use a preconditioner. <code>ExaPF.jl</code> implements an overlapping Schwarz preconditioner, tailored for GPU usage. To build an instance with 8 blocks, just write</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import KrylovPreconditioners as KP</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; npartitions = 8;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; jac_gpu = jx_gpu.J;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `jx_gpu` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; precond = KP.BlockJacobiPreconditioner(jac_gpu, npartitions, CUDABackend());</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `jac_gpu` not defined</code></pre><p>You can attach the preconditioner to an BICGSTAB algorithm simply as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; linear_solver = ExaPF.Bicgstab(jac_gpu; P=precond);</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `precond` not defined</code></pre><p>(this will use the BICGSTAB algorithm implemented in <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl/">Krylov.jl</a>).</p><p>We need to update accordingly the tolerance of the Newton-Raphson algorithm (the iterative solver is less accurate than the direct solver):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pf_algo = NewtonRaphson(; verbose=1, tol=1e-7)</code><code class="nohighlight hljs ansi" style="display:block;">NewtonRaphson(20, 1.0e-7, 1)</code></pre><p>We reset the variables to their initial values:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ExaPF.init!(polar_gpu, stack_gpu)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `polar_gpu` not defined</code></pre><p>Then, solving the power flow with the iterative solvers directly translates to one call to <code>nlsolve!</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; convergence = ExaPF.nlsolve!(pf_algo, jx_gpu, stack_gpu; linear_solver=linear_solver)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `jx_gpu` not defined</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorials/direct_solver/">Power flow: direct solver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Saturday 28 February 2026 21:14">Saturday 28 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
